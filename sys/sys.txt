# Description of syscall arguments.

# A syscall is described as:
#	syscallname "(" [arg ["," arg]*] ")" [type]
#	arg = argname type
#	argname = identifier
#	type = typename [ "[" type-options "]" ]
#	typename = "fd" | "fileoff" | "buffer" | "vma" , "len" | "flags" | "filename" | "ptr" | "array" | "intN" | "intptr"
#	type-options = [type-opt ["," type-opt]]
# common type-options include:
#	"opt" - the argument is optional (like mmap fd argument, or accept peer argument)
# rest of the type-options are type-specific:
#	"fd": file descriptor, type-options: kind of fd (file/sock/pipe/rand) (optional)
#	"fileoff": offset within a file, type-options: argname of the file
#	"buffer": a pointer to a memory buffer (like read/write buffer argument), type-options: direction (in/out/inout)
#	"string": a pointer to a memory buffer, similar to buffer[in]
#	"vma": a pointer to a set of pages (used as input for mmap/munmap/mremap/madvise)
#	"len": length of buffer/vma/arrayptr (for array it is number of elements), type-options: argname of the object
#	"flags": a set of flags, type-options: reference to flags description
#	"filename": a file/link/dir name
#	"ptr": a pointer to an object, type-options: type of the object; direction (in/out/inout)
#	"array": a variable-length array, type-options: type of elements
#	"intN"/"intptr": an integer without a particular meaning
# flags/len/flags also have trailing underlying type type-option when used in structs/pointers.
#
# Flags are described as:
#	flagname = const ["," const]
#
# Structs are described as:
#	structname struct "{" "\n" (fieldname type "\n")+ "}"

# Packages with required headers:
# sudo apt-get install libnuma-dev

include <sys/types.h>
include <sys/socket.h>
include <sys/select.h>
include <sys/ptrace.h>
include <sys/fanotify.h>
include <sys/inotify.h>
include <sys/resource.h>
include <sys/stat.h>
include <sys/xattr.h>
include <sys/mman.h>
include <sys/time.h>
include <sys/ipc.h>
include <sys/shm.h>
include <sys/msg.h>
include <sys/sem.h>
include <sys/prctl.h>
include <sys/mount.h>
include <sys/epoll.h>
include <sys/signalfd.h>
include <sys/eventfd.h>
include <sys/timerfd.h>
include <sys/personality.h>
include <sys/wait.h>
include <sys/user.h>
include <sys/socket.h>
include <sys/ioctl.h>

include <linux/futex.h>
include <linux/aio_abi.h>
include <linux/kexec.h>
include <linux/seccomp.h>
include <linux/elf.h>
include <linux/fs.h>
include <linux/fiemap.h>
include <linux/kd.h>
include <linux/vt.h>
include <linux/fuse.h>

include <asm/prctl.h>

include <termios.h>
include <fcntl.h>
include <sched.h>
include <mqueue.h>
include <time.h>
include <numaif.h>
include <netinet/in.h>
include <netinet/ip.h>
include <netinet/tcp.h>
include <netinet/udp.h>
include <drm/drm.h>




open(file filename, flags flags[open_flags], mode flags[open_mode]) fd
openat(fd fd[dir], file filename, flags flags[open_flags], mode flags[open_mode]) fd
creat(file filename, mode flags[open_mode]) fd
close(fd fd)
read(fd fd, buf buffer[out], count len[buf]) len[buf]
pread64(fd fd, buf buffer[out], count len[buf], pos fileoff[fd])
readv(fd fd, vec ptr[in, array[iovec_out]], vlen len[vec])
preadv(fd fd, vec ptr[in, array[iovec_out]], vlen len[vec], off fileoff[fd])
write(fd fd, buf buffer[in], count len[buf]) len[buf]
pwrite64(fd fd, buf buffer[in], count len[buf], pos fileoff[fd])
writev(fd fd, vec ptr[in, array[iovec_in]], vlen len[vec])
pwritev(fd fd, vec ptr[in, array[iovec_in]], vlen len[vec], off fileoff[fd])
lseek(fd fd, offset fileoff[fd], whence flags[seek_whence])

dup(oldfd fd) fd
dup2(oldfd fd, newfd fd) fd
dup3(oldfd fd, newfd fd, flags flags[dup_flags]) fd

pipe(pipefd ptr[out, pipefd])
pipe2(pipefd ptr[out, pipefd], flags flags[pipe_flags])

tee(fdin fd, fdout fd, len int64, f flags[splice_flags])
splice(fdin fd, offin fileoff[fdin], fdout fd, offout fileoff[fdout], len int64, f flags[splice_flags])
vmsplice(fd fd, vec ptr[in, array[iovec_in]], vlen len[vec], f flags[splice_flags])
sendfile(fdout fd, fdin fd, off ptr[inout, fileoff[fdin, int64], opt], count int64)

stat(file filename, statbuf ptr[out, stat])
lstat(file filename, statbuf ptr[out, stat])
fstat(fd fd, statbuf ptr[out, stat])

poll(fds ptr[in, array[pollfd]], nfds len[fds], timeout int32)
ppoll(fds ptr[in, array[pollfd]], nfds len[fds], tsp ptr[in, timespec], sigmask ptr[in, sigset], size len[sigmask])
select(n len[inp], inp ptr[inout, fd_set], outp ptr[inout, fd_set], exp ptr[inout, fd_set], tvp ptr[inout, timeval])
pselect6(n len[inp], inp ptr[inout, fd_set], outp ptr[inout, fd_set], exp ptr[inout, fd_set], tvp ptr[inout, timespec], sig ptr[in, sigset_size])

epoll_create(size int32) fd[epoll]
epoll_create1(flags flags[epoll_flags]) fd[epoll]
epoll_ctl(epfd fd[epoll], op flags[epoll_op], fd fd, ev ptr[in, epoll_event])
epoll_wait(epfd fd[epoll], events ptr[out, array[epoll_event]], maxevents len[events], timeout int32)
epoll_pwait(epfd fd[epoll], events ptr[out, array[epoll_event]], maxevents len[events], timeout int32, sigmask ptr[in, sigset], size len[sigmask])

signalfd(fd fd, mask ptr[in, sigset], size len[mask]) fd[signal]
signalfd4(fd fd, mask ptr[in, sigset], size len[mask], flags flags[signalfd_flags]) fd[signal]
eventfd(initval int32) fd[event]
eventfd2(initval int32, flags flags[eventfd_flags]) fd[event]
timerfd_create(clockid flags[clock_type], flags flags[timerfd_create_flags]) fd[timer]
timerfd_settime(fd fd[timer], flags flags[timerfd_settime_flags], new ptr[in, itimerspec], old ptr[out, itimerspec])
timerfd_gettime(fd fd[timer], cur ptr[out, itimerspec])

mmap(addr vma, len len[addr], prot flags[mmap_prot], flags flags[mmap_flags], fd fd[file, opt], offset fileoff[fd]) vma
munmap(addr vma, len len[addr])
mremap(addr vma, len len[addr], newlen len[newaddr], flags flags[mremap_flags], newaddr vma) vma
remap_file_pages(addr vma, size len[addr], prot flags[mmap_prot], pgoff intptr, flags flags[mmap_flags])
mprotect(addr vma, len len[addr], prot flags[mmap_prot])
msync(addr vma, len len[addr], f flags[msync_flags])
madvise(addr vma, len len[addr], advice flags[madvise_flags])
fadvise64(fd fd, offset fileoff[fd], len intptr, advice flags[fadvise_flags])
readahead(fd fd, off intptr, count intptr)
mbind(addr vma, len len[addr], mode flags[mbind_mode], nodemask ptr[in, int64], maxnode intptr, flags flags[mbind_flags])
move_pages(pid pid, nr len[pages], pages ptr[in, array[vma]], nodes ptr[in, array[int32], opt], status ptr[out, array[int32]], flags flags[move_pages_flags])
migrate_pages(pid pid, maxnode intptr, old ptr[in, int64], new ptr[in, int64])
set_mempolicy(mode flags[mbind_mode], nodemask ptr[in, int64], maxnode intptr)
get_mempolicy(mode ptr[out, int32], nodemask ptr[out, int64], maxnode intptr, addr vma, flags flags[mempolicy_flags])
mincore(addr vma, size len[addr], vec buffer[out])
mlock(addr vma, size len[addr])
munlock(addr vma, size len[addr])
mlockall(flags flags[mlockall_flags])
munlockall()
memfd_create(name string, flags flags[memfd_flags]) fd
unshare(flags flags[clone_flags])
kcmp(pid1 pid, pid2 pid, type flags[kcmp_flags], fd1 fd, fd2 fd)

futex(addr ptr[in, int32], op flags[futex_op], val intptr, timeout ptr[in, timespec], addr2 ptr[in, int32], val3 intptr)
set_robust_list(head ptr[in, robust_list], len len[head])
get_robust_list(pid pid, head ptr[in, ptr[out, robust_list]], len ptr[inout, len[head, intptr]])
restart_syscall()

socket(domain flags[socket_domain], type flags[socket_type], proto int8) fd[sock]
socketpair(domain flags[socket_domain], type flags[socket_type], proto int8, fds ptr[out, pipefd])
accept(fd fd[sock], peer ptr[out, sockaddr, opt], peerlen ptr[inout, len[peer, int32]]) fd[sock]
accept4(fd fd[sock], peer ptr[out, sockaddr, opt], peerlen ptr[inout, len[peer, int32]], flags flags[accept_flags]) fd[sock]
# TODO: must not bind to port 0, that will result in a random port which is not reproducible
bind(fd fd[sock], addr ptr[in, sockaddr], addrlen len[addr])
listen(fd fd[sock], backlog int32)
connect(fd fd[sock], addr ptr[in, sockaddr], addrlen len[addr])
shutdown(fd fd[sock], how flags[shutdown_flags])
sendto(fd fd[sock], buf buffer[in], len len[buf], f flags[send_flags], addr ptr[in, sockaddr, opt], addrlen len[addr])
sendmsg(fd fd[sock], msg ptr[in, send_msghdr], f flags[send_flags])
sendmmsg(fd fd[sock], mmsg ptr[in, array[send_msghdr]], vlen len[mmsg], f flags[send_flags])
recvfrom(fd fd[sock], buf buffer[out], len len[buf], f flags[recv_flags], addr ptr[in, sockaddr, opt], addrlen len[addr])
recvmsg(fd fd[sock], msg ptr[in, recv_msghdr], f flags[recv_flags])
recvmmsg(fd fd[sock], mmsg ptr[in, array[recv_msghdr]], vlen len[mmsg], f flags[recv_flags])
getsockname(fd fd[sock], addr ptr[out, sockaddr], addrlen ptr[inout, len[addr, int32]])
getpeername(fd fd[sock], peer ptr[out, sockaddr], peerlen ptr[inout, len[peer, int32]])
getsockopt(fd fd[sock], level int32, optname int32, optval ptr[out, ioctl_arg], optlen ptr[inout, len[optval, int32]])
setsockopt(fd fd[sock], level int32, optname int32, optval ptr[in, ioctl_arg], optlen len[optval])
getsockopt$sock_int(fd fd[sock], level const[SOL_SOCKET], optname flags[sockopt_opt_sock_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$sock_int(fd fd[sock], level const[SOL_SOCKET], optname flags[sockopt_opt_sock_int], optval ptr[in, int32], optlen len[optval])
getsockopt$sock_str(fd fd[sock], level const[SOL_SOCKET], optname const[SO_BINDTODEVICE], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$sock_str(fd fd[sock], level const[SOL_SOCKET], optname const[SO_BINDTODEVICE], optval string, optlen len[optval])
getsockopt$sock_linger(fd fd[sock], level const[SOL_SOCKET], optname const[SO_LINGER], optval ptr[out, linger], optlen ptr[inout, len[optval, int32]])
setsockopt$sock_linger(fd fd[sock], level const[SOL_SOCKET], optname const[SO_LINGER], optval ptr[in, linger], optlen len[optval])
getsockopt$sock_cred(fd fd[sock], level const[SOL_SOCKET], optname const[SO_PEERCRED], optval ptr[out, ucred], optlen ptr[inout, len[optval, int32]])
setsockopt$sock_cred(fd fd[sock], level const[SOL_SOCKET], optname const[SO_PEERCRED], optval ptr[in, ucred], optlen len[optval])
getsockopt$sock_timeval(fd fd[sock], level const[SOL_SOCKET], optname flags[sockopt_opt_sock_timeval], optval ptr[out, timeval], optlen ptr[inout, len[optval, int32]])
setsockopt$sock_timeval(fd fd[sock], level const[SOL_SOCKET], optname flags[sockopt_opt_sock_timeval], optval ptr[in, timeval], optlen len[optval])
getsockopt$tcp_int(fd fd[sock], level const[IPPROTO_TCP], optname flags[sockopt_opt_tcp_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$tcp_int(fd fd[sock], level const[IPPROTO_TCP], optname flags[sockopt_opt_tcp_int], optval ptr[in, int32], optlen len[optval])
getsockopt$tcp_buf(fd fd[sock], level const[IPPROTO_TCP], optname const[TCP_INFO], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$tcp_buf(fd fd[sock], level const[IPPROTO_TCP], optname const[TCP_INFO], optval buffer[in], optlen len[optval])
getsockopt$udp_int(fd fd[sock], level const[IPPROTO_UDP], optname const[UDP_CORK], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$udp_int(fd fd[sock], level const[IPPROTO_UDP], optname const[UDP_CORK], optval ptr[in, int32], optlen len[optval])
getsockopt$ip_int(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_int(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_int], optval ptr[in, int32], optlen len[optval])
getsockopt$ip_mreq(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_mreq], optval ptr[out, ip_mreq], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_mreq(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_mreq], optval ptr[in, ip_mreq], optlen len[optval])
getsockopt$ip_mreqn(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_mreq], optval ptr[out, ip_mreqn], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_mreqn(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_mreq], optval ptr[in, ip_mreqn], optlen len[optval])
getsockopt$ip_mreqsrc(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_mreqsrc], optval ptr[out, ip_mreq_source], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_mreqsrc(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_mreqsrc], optval ptr[in, ip_mreq_source], optlen len[optval])
getsockopt$ip_msfilter(fd fd[sock], level const[IPPROTO_IP], optname const[IP_MSFILTER], optval ptr[out, ip_msfilter], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_msfilter(fd fd[sock], level const[IPPROTO_IP], optname const[IP_MSFILTER], optval ptr[in, ip_msfilter], optlen len[optval])
getsockopt$ip_mtu(fd fd[sock], level const[IPPROTO_IP], optname const[IP_MTU_DISCOVER], optval ptr[out, flags[ip_mtu_discover, int32]], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_mtu(fd fd[sock], level const[IPPROTO_IP], optname const[IP_MTU_DISCOVER], optval ptr[in, flags[ip_mtu_discover, int32]], optlen len[optval])
getsockopt$ip_opts(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_opts], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_opts(fd fd[sock], level const[IPPROTO_IP], optname flags[sockopt_opt_ip_opts], optval buffer[in], optlen len[optval])
getsockopt$ip_pktinfo(fd fd[sock], level const[IPPROTO_IP], optname const[IP_PKTINFO], optval ptr[out, in_pktinfo], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_pktinfo(fd fd[sock], level const[IPPROTO_IP], optname const[IP_PKTINFO], optval ptr[in, in_pktinfo], optlen len[optval])
getsockopt$ip_ipsec(fd fd[sock], level const[IPPROTO_IP], optname const[IP_IPSEC_POLICY], optval ptr[out, xfrm_filer], optlen ptr[inout, len[optval, int32]])
setsockopt$ip_ipsec(fd fd[sock], level const[IPPROTO_IP], optname const[IP_IPSEC_POLICY], optval ptr[in, xfrm_filer], optlen len[optval])
getsockopt$ipv6_int(fd fd[sock], level const[IPPROTO_IPV6], optname flags[sockopt_opt_ipv6_int], optval ptr[out, int32], optlen ptr[inout, len[optval, int32]])
setsockopt$ipv6_int(fd fd[sock], level const[IPPROTO_IPV6], optname flags[sockopt_opt_ipv6_int], optval ptr[in, int32], optlen len[optval])
getsockopt$ipv6_mreq(fd fd[sock], level const[IPPROTO_IPV6], optname flags[sockopt_opt_ipv6_mreq], optval ptr[out, ipv6_mreq], optlen ptr[inout, len[optval, int32]])
setsockopt$ipv6_mreq(fd fd[sock], level const[IPPROTO_IPV6], optname flags[sockopt_opt_ipv6_mreq], optval ptr[in, ipv6_mreq], optlen len[optval])
getsockopt$ipv6_mtu(fd fd[sock], level const[IPPROTO_IPV6], optname const[IPV6_MTU_DISCOVER], optval ptr[out, flags[ip_mtu_discover, int32]], optlen ptr[inout, len[optval, int32]])
setsockopt$ipv6_mtu(fd fd[sock], level const[IPPROTO_IPV6], optname const[IPV6_MTU_DISCOVER], optval ptr[in, flags[ip_mtu_discover, int32]], optlen len[optval])
getsockopt$ipv6_opts(fd fd[sock], level const[IPPROTO_IPV6], optname const[IPV6_2292PKTOPTIONS], optval buffer[out], optlen ptr[inout, len[optval, int32]])
setsockopt$ipv6_opts(fd fd[sock], level const[IPPROTO_IPV6], optname const[IPV6_2292PKTOPTIONS], optval buffer[in], optlen len[optval])

# Almighty!
ioctl(fd fd, cmd intptr, arg ptr[inout, ioctl_arg])

ioctl$void(fd fd, cmd flags[ioctl_void])
ioctl$int_in(fd fd, cmd flags[ioctl_int_in], v ptr[in, int64])
ioctl$int_out(fd fd, cmd flags[ioctl_int_out], v ptr[out, intptr])
ioctl$fiemap(fd fd, cmd const[FS_IOC_FIEMAP], v ptr[in, fiemap])

fcntl$dupfd(fd fd, cmd flags[fcntl_dupfd], arg fd) fd
fcntl$getflags(fd fd, cmd flags[fcntl_getflags])
fcntl$setflags(fd fd, cmd const[F_SETFD], flags flags[fcntl_flags])
fcntl$setstatus(fd fd, cmd const[F_SETFL], flags flags[fcntl_status])
fcntl$lock(fd fd, cmd flags[fcntl_lock], lock ptr[in, flock])
fcntl$getown(fd fd, cmd const[F_GETOWN]) pid
fcntl$setown(fd fd, cmd const[F_SETOWN], pid pid)
fcntl$getownex(fd fd, cmd const[F_GETOWN_EX], arg ptr[out, f_owner_ex])
fcntl$setownex(fd fd, cmd const[F_SETOWN_EX], arg ptr[in, f_owner_ex])
fcntl$setsig(fd fd, cmd const[F_SETSIG], sig signalno)
fcntl$setlease(fd fd, cmd const[F_SETLEASE], typ flags[flock_type])
fcntl$notify(fd fd, cmd flags[fcntl_notify], typ flags[fcntl_notify])
fcntl$setpipe(fd fd, cmd const[F_SETPIPE_SZ], sz intptr)
fcntl$addseals(fd fd, cmd const[F_ADD_SEALS], seals flags[seal_types])

ptrace(req flags[ptrace_req], pid pid)
ptrace$peek(req flags[ptrace_req_peek], pid pid, addr ptr[out, intptr])
ptrace$poke(req flags[ptrace_req_poke], pid pid, addr ptr[out, intptr], data intptr)
ptrace$peekuser(req const[PTRACE_PEEKUSER], pid pid, addr intptr)
ptrace$pokeuser(req const[PTRACE_POKEUSER], pid pid, addr intptr, data intptr)
ptrace$getregs(req flags[ptrace_req_getregs], pid pid, ignored intptr, data buffer[out])
ptrace$getregset(req const[PTRACE_GETREGSET], pid pid, what flags[pthread_regset], data ptr[in, iovec_out])
ptrace$setregs(req flags[ptrace_req_setregs], pid pid, ignored intptr, data buffer[in])
ptrace$setregset(req const[PTRACE_SETREGSET], pid pid, what flags[pthread_regset], data ptr[in, iovec_in])
ptrace$getsig(req const[PTRACE_GETSIGINFO], pid pid, ignored intptr, data ptr[out, siginfo])
ptrace$setsig(req const[PTRACE_SETSIGINFO], pid pid, ignored intptr, data ptr[in, siginfo])
ptrace$setopts(req flags[ptrace_req_setopts], pid pid, ignored intptr, flags flags[ptrace_options])
ptrace$getenv(req const[PTRACE_GETEVENTMSG], pid pid, ignored intptr, data ptr[out, intptr])
ptrace$cont(req flags[ptrace_req_cont], pid pid, ignored intptr, data intptr)

io_setup(n int32, ctx ptr[out, io_ctx])
io_destroy(ctx io_ctx)
io_getevents(ctx io_ctx, min_nr intptr, nr len[events], events ptr[out, array[io_event]], timeout ptr[in, timespec])
# Prog knows that poiners passed in iocbpp needs to be forwarded to io_cancel.
io_submit(ctx io_ctx, nr len[iocbpp], iocbpp ptr[in, array[ptr[in, iocb]]])
io_cancel(ctx io_ctx, iocb ptr[in, iocb], res ptr[out, io_event])

capget(hdr ptr[in, cap_header], data ptr[in, cap_data])
capset(hdr ptr[in, cap_header], data ptr[in, cap_data])

prctl$void(option flags[prctl_code_void])
prctl$intptr(option flags[prctl_code_intptr], arg intptr)
prctl$getreaper(option flags[prctl_code_getreaper], arg ptr[out, intptr])
prctl$setendian(option const[PR_SET_ENDIAN], arg flags[prctl_endian])
prctl$setfpexc(option const[PR_SET_FPEXC], arg flags[prctl_fpexc])
prctl$setname(option const[PR_SET_NAME], name string)
prctl$getname(option const[PR_GET_NAME], name buffer[out])
prctl$setptracer(option const[PR_SET_PTRACER], pid pid)
prctl$seccomp(option const[PR_SET_SECCOMP], mode flags[prctl_seccomp_mode], prog ptr[in, sock_fprog])
prctl$setmm(option const[PR_SET_MM], option flags[prctl_mm_option], val vma)

arch_prctl(code flags[arch_prctl_code], addr ptr[in, ioctl_arg])
seccomp(op flags[seccomp_op], flags flags[seccomp_flags], prog ptr[in, sock_fprog])

add_key(type string, desc string, payload buffer[in, opt], paylen len[payload], keyring flags[keyring_type]) key
request_key(type string, desc string, callout string, keyring flags[keyring_type]) key
keyctl$get_keyring_id(code const[KEYCTL_GET_KEYRING_ID], key key, create intptr)
keyctl$join(code const[KEYCTL_JOIN_SESSION_KEYRING], session string)
keyctl$update(code const[KEYCTL_UPDATE], key key, payload buffer[in, opt], paylen len[payload])
keyctl$revoke(code const[KEYCTL_REVOKE], key key)
keyctl$describe(code const[KEYCTL_DESCRIBE], key key, desc buffer[out], len len[desc])
keyctl$clear(code const[KEYCTL_CLEAR], key key)
keyctl$link(code const[KEYCTL_LINK], key1 key, key2 key)
keyctl$unlink(code const[KEYCTL_UNLINK], key1 key, key2 key)
keyctl$search(code const[KEYCTL_SEARCH], key key, type string, desc string, ring key)
keyctl$read(code const[KEYCTL_READ], key key, payload buffer[out], len len[payload])
keyctl$chown(code const[KEYCTL_CHOWN], key key, uid uid, gid gid)
# perm is a mask of KEY_POS_VIEW, etc consants, but they cover almost whole int32.
keyctl$setperm(code const[KEYCTL_SETPERM], key key, perm int32)
keyctl$instantiate(code const[KEYCTL_INSTANTIATE], key key, payload buffer[in, opt], paylen len[payload], ring key)
keyctl$negate(code const[KEYCTL_NEGATE], key key, timeout intptr, ring key)
keyctl$set_reqkey_keyring(code const[KEYCTL_SET_REQKEY_KEYRING], reqkey flags[reqkey_keyring])
keyctl$set_timeout(code const[KEYCTL_SET_TIMEOUT], key key, timeout int32)
keyctl$assume_authority(code const[KEYCTL_ASSUME_AUTHORITY], key key)
keyctl$get_security(code const[KEYCTL_GET_SECURITY], key key, label buffer[out], len len[label])
keyctl$session_to_parent(code const[KEYCTL_SESSION_TO_PARENT])
keyctl$reject(code const[KEYCTL_REJECT], key key, timeout intptr, error intptr, ring key)
keyctl$instantiate_iov(code const[KEYCTL_INSTANTIATE_IOV], key key, payload ptr[in, array[iovec_in]], len len[payload], ring key)
keyctl$invalidate(code const[KEYCTL_INVALIDATE], key key)
keyctl$get_persistent(code const[KEYCTL_GET_PERSISTENT], uid uid, key key)

mq_open(name string, flags flags[mq_open_flags], mode flags[open_mode], attr ptr[in, mq_attr]) fd[mq]
mq_timedsend(mqd fd[mq], msg buffer[in], msglen len[msg], prio intptr, timeout ptr[in, timespec, opt])
mq_timedreceive(mqd fd[mq], msg buffer[out], msglen len[msg], prio intptr, timeout ptr[in, timespec, opt])
mq_notify(mqd fd[mq], notif ptr[in, sigevent])
mq_getsetattr(mqd fd[mq], attr ptr[in, mq_attr], oldattr ptr[out, mq_attr, opt])
mq_unlink(name string)

msgget(key int32, flags flags[msgget_flags]) ipc[msq]
msgsnd(msqid ipc[msq], msgp buffer[in], flags flags[msg_flags])
msgrcv(msqid ipc[msq], msgp buffer[out], sz len[msgp], typ intptr, flags flags[msg_flags])
msgctl(msqid ipc[msq], cmd flags[msgctl_cmd], buf ptr[inout, msqid_ds])

semget(key int32, nsems intptr, flags flags[semget_flags]) ipc[sem]
semop(semid ipc[sem], ops ptr[in, array[sembuf]], nops len[ops])
semtimedop(semid ipc[sem], ops ptr[in, array[sembuf]], nops len[ops], timeout ptr[in, timespec])
semctl(semid ipc[sem], semnum intptr, cmd flags[semctl_cmd], arg ptr[in, semid_ds])

# The unused arg is unused by syscall (does not exist at all),
# but it helps to generate sane size values.
shmget(key int32, size len[unused], flags flags[shmget_flags], unused vma) ipc[shm]
shmat(shmid ipc[shm], addr vma, flags flags[shmat_flags])
shmctl(shmid ipc[shm], cmd flags[shmctl_cmd], buf ptr[inout, shmid_ds])
shmdt(addr vma)

mknod(file filename, mode flags[mknod_mode], dev int32)
mknodat(dirfd fd[dir], file filename, mode flags[mknod_mode], dev int32)
chmod(file filename, mode flags[open_mode])
fchmod(fd fd, mode flags[open_mode])
fchmodat(dirfd fd[dir], file filename, mode flags[open_mode])
chown(file filename, uid uid, gid gid)
lchown(file filename, uid uid, gid gid)
fchown(fd fd, uid uid, gid gid)
fchownat(dirfd fd[dir], file filename, uid uid, gid gid, flags flags[fchownat_flags])
fallocate(fd fd, mode flags[fallocate_mode], off intptr, len intptr)
faccessat(dirfd fd[dir], pathname filename, mode flags[open_mode], flags flags[faccessat_flags])
utime(filename filename, times ptr[in, utimbuf])
utimes(filename filename, times ptr[in, itimerval])
futimesat(dir fd[dir], pathname filename, times ptr[in, itimerval])
utimensat(dir fd[dir], pathname filename, times ptr[in, itimerval], flags flags[utimensat_flags])

getgid() gid
getegid() gid
setuid(uid uid)
setgid(gid gid)
getuid() uid
geteuid() uid
setpgid(pid pid, pgid pid)
getpgid(pid pid) pid
getpgrp(pid pid) pid
getpid() pid
gettid() pid
setreuid(ruid uid, euid uid)
setregid(rgid gid, egid gid)
setresuid(ruid uid, euid uid, suid uid)
setresgid(rgid gid, egid gid, sgid gid)
getresuid(ruid ptr[out, uid], euid ptr[out, uid], suid ptr[out, uid])
getresgid(rgid ptr[out, gid], egid ptr[out, gid], sgid ptr[out, gid])
setfsuid(fsuid uid)
setfsgid(fsgid gid)
getgroups(size len[list], list ptr[inout, array[gid]])
setgroups(size len[list], list ptr[in, array[gid]])
personality(persona flags[personality_flags])
# Don't mess with parent (fuzzer). If we ptrace attach to it, it will hang.
# If we setrlimit for parent, it will misbehave. Killing - the same. Nothing good.
#getppid() pid
#getsid(pid pid) pid
#setsid() pid

inotify_init() fd[inotify]
inotify_init1(flags flags[inotify_flags]) fd[inotify]
inotify_add_watch(fd fd[inotify], file filename, mask flags[inotify_mask]) inotifydesc
inotify_rm_watch(fd fd[inotify], wd inotifydesc)
fanotify_init(flags flags[fanotify_flags], events flags[fanotify_events]) fd[fanotify]
fanotify_mark(fd fd[fanotify], flags flags[fanotify_mark], mask flags[fanotify_mask], fd fd[dir], path filename)

link(old filename, new filename)
linkat(oldfd fd[dir], old filename, newfd fd[dir], new filename, flags flags[linkat_flags])
symlinkat(old filename, newfd fd[dir], new filename)
symlink(old filename, new filename)
unlink(path filename)
unlinkat(fd fd[dir], path filename, flags flags[unlinkat_flags])
readlink(path filename, buf buffer[out], siz len[buf])
readlinkat(fd fd[dir], path filename, buf buffer[out], siz len[buf])
rename(old filename, new filename)
renameat(oldfd fd[dir], old filename, newfd fd[dir], new filename)
renameat2(oldfd fd[dir], old filename, newfd fd[dir], new filename, flags flags[renameat2_flags])
mkdir(path filename, mode flags[open_mode])
mkdirat(fd fd[dir], path filename, mode flags[open_mode])
rmdir(path filename)
truncate(file filename, len intptr)
ftruncate(fd fd, len intptr)
flock(fd fd, op flags[flock_op])
fsync(fd fd)
fdatasync(fd fd)
sync()
syncfs(fd fd)
sync_file_range(fd fd, off intptr, nbytes intptr, flags flags[sync_file_flags])
lookup_dcookie(cookie int64, buf buffer[out], len len[buf])
getdents(fd fd[dir], ent buffer[out], count len[ent])
getdents64(fd fd[dir], ent buffer[out], count len[ent])
name_to_handle_at(fd fd[dir], file filename, handle ptr[in, file_handle], mnt ptr[out, int32], flags flags[name_to_handle_at_flags])
open_by_handle_at(mountdirfd fd, handle ptr[in, file_handle], flags flags[open_flags])

mount(src filename, dst filename, type filesystem, flags flags[mount_flags], data buffer[in])
mount$fs(src filesystem, dst filename, type filesystem, flags flags[mount_flags], data buffer[in])
umount2(path filename, flags flags[umount_flags])
pivot_root(new_root filename, put_old filename)

sysfs$1(option flags[sysfs_opt1], fsname string)
sysfs$2(option flags[sysfs_opt2], fsindex intptr, fsname buffer[out])
sysfs$3(option flags[sysfs_opt3])
statfs(path filename, buf buffer[out])
fstatfs(fd fd, buf buffer[out])

uselib(lib filename)
init_module(mod string, len len[mod], args string)
finit_module(fd fd, args string, flags flags[finit_module_flags])
delete_module(name string, flags flags[delete_module_flags])
kexec_load(entry intptr, nr_segments len[segments], segments ptr[in, array[kexec_segment]], flags flags[kexec_load_flags])
get_kernel_syms(table buffer[out])
syslog(cmd flags[syslog_cmd], buf buffer[out, opt], len len[buf])
uname(buf buffer[out])
sysinfo(info buffer[out])
ustat(dev intptr, buf ptr[out, ustat])
acct(filename filename[opt])

getrusage(who flags[rusage_who], usage ptr[out, rusage])
getrlimit(res flags[rlimit_type], rlim ptr[out, rlimit])
setrlimit(res flags[rlimit_type], rlim ptr[in, rlimit])
prlimit64(pid pid, res flags[rlimit_type], new ptr[in, rlimit, opt], old ptr[out, rlimit, opt])

iopl(level int8)
ioperm(from intptr, num intptr, on intptr)
ioprio_get$pid(which flags[ioprio_which_pid], who pid)
ioprio_get$uid(which flags[ioprio_which_uid], who uid)
ioprio_set$pid(which flags[ioprio_which_pid], who pid, prio intptr)
ioprio_set$uid(which flags[ioprio_which_uid], who uid, prio intptr)
setns(fd fd, type flags[ns_type])

setxattr(path filename, name string, val string, size len[val], flags flags[setxattr_flags])
lsetxattr(path filename,  name string, val string, size len[val], flags flags[setxattr_flags])
fsetxattr(fd fd,  name string, val string, size len[val], flags flags[setxattr_flags])
getxattr(path filename,  name string, val buffer[out], size len[val])
lgetxattr(path filename,  name string, val buffer[out], size len[val])
fgetxattr(fd fd,  name string, val buffer[out], size len[val])
listxattr(path filename, list buffer[out], size len[list])
llistxattr(path filename, list buffer[out], size len[list])
flistxattr(fd fd, list buffer[out], size len[list])
removexattr(path filename,  name string)
lremovexattr(path filename,  name string)
fremovexattr(fd fd,  name string)

time(t ptr[out, intptr])
clock_gettime(id flags[clock_id], tp ptr[out, timespec])
clock_settime(id flags[clock_id], tp ptr[in, timespec])
clock_adjtime(id flags[clock_id], tx ptr[in, timex])
clock_getres(id flags[clock_id], tp ptr[out, timespec])
clock_nanosleep(id flags[clock_id], flags flags[timer_flags], rqtp ptr[in, timespec], rmtp ptr[out, timespec, opt])
timer_create(id flags[clock_id], ev ptr[in, sigevent], timerid ptr[out, timerid])
timer_gettime(timerid timerid, setting ptr[out, itimerspec])
timer_getoverrun(timerid timerid)
timer_settime(timerid timerid, flags flags[timer_flags], new ptr[in, itimerspec], old ptr[out, itimerspec, opt])
timer_delete(timerid timerid)
rt_sigaction(sig signalno, act ptr[in, sigaction], oact ptr[out, sigaction, opt], sigsetsize len[fake], fake ptr[out, sigset])
rt_sigprocmask(how flags[sigprocmask_how], nset ptr[in, sigset], oset ptr[out, sigset, opt], sigsetsize len[nset])
rt_sigreturn()
rt_sigpending(set ptr[out, sigset], sigsetsize len[set])
rt_sigtimedwait(these ptr[in, sigset], info ptr[out, siginfo, opt], ts ptr[in, timespec], sigsetsize len[these])
rt_sigsuspend(new ptr[in, sigset], sigsetsize len[new])
rt_sigqueueinfo(pid pid, sig signalno, info ptr[in, siginfo])
rt_tgsigqueueinfo(gid pid, tid pid, sig signalno, info ptr[in, siginfo])
sigaltstack(ss vma, oss ptr[out, intptr, opt])
tgkill(gid pid, tid pid, sig signalno)
tkill(tid pid, sig signalno)
pause()
alarm(seconds intptr)
nanosleep(req ptr[in, timespec], rem ptr[out, timespec, opt])
getitimer(which flags[getitimer_which], cur ptr[out, itimerval])
setitimer(which flags[getitimer_which], new ptr[in, itimerval], old ptr[out, itimerval, opt])
exit(code intptr)
exit_group(code intptr)
waitid(which flags[waitid_which], pid pid, infop ptr[out, siginfo, opt], options flags[wait_options], ru ptr[out, rusage, opt])
wait4(pid pid, status ptr[out, int32, opt], options flags[wait_options], ru ptr[out, rusage, opt])
times(buf ptr[out, tms])
# Can send signals to all processes (pid=-1).
#kill(pid pid, sig signalno)

set_thread_area(info ptr[in, user_desc])
get_thread_area(info ptr[in, user_desc])
set_tid_address(tidptr ptr[out, int32])
getpriority(which flags[priority_which], who pid)
setpriority(which flags[priority_which], who pid, prio intptr)
sched_getscheduler(pid pid)
sched_setscheduler(pid pid, policy flags[sched_policy], prio ptr[in, int32])
sched_rr_get_interval(pid pid, tp ptr[out, timespec])
sched_getparam(pid pid, prio ptr[out, int32])
sched_setparam(pid pid, prio ptr[in, int32])
sched_getaffinity(pid pid, cpusetsize len[mask], mask ptr[out, int64])
sched_setaffinity(pid pid, cpusetsize len[mask], mask ptr[in, int64])
sched_getattr(pid pid, attr ptr[out, sched_attr], size len[attr], flags flags[sched_attr_flags])
sched_setattr(pid pid, attr ptr[in, sched_attr], flags flags[sched_attr_flags])
sched_yield()




# TODO: need something better
ioctl_arg {
	a0	intptr
	a1	intptr
	a2	intptr
	a3	intptr
	a4	intptr
	a5	intptr
	a6	intptr
	a7	intptr
}

pipefd {
	rfd	fd
	wfd	fd
}

iovec_in {
	addr	buffer[in]
	len	len[addr, intptr]
}

iovec_out {
	addr	buffer[out]
	len	len[addr, intptr]
}

stat {
	dev	int16
	pad	int16
	ino	int32
	mode	int16
	nlink	int16
	uid	uid
	gid	gid
	rdev	int16
	pad	int16
	size	int32
	blksize	int32
	blocks	int32
	atime	int32
	ansec	int32
	mtime	int32
	mnsec	int32
	ctime	int32
	cnsec	int32
	pad	int32
	pad	int32
}

pollfd {
	fd	fd
	events	int16
	revents	int16
}

send_msghdr {
	addr	ptr[in, sockaddr]
	addrlen	len[addr, int32]
	vec	ptr[in, array[iovec_in]]
	vlen	len[vec, intptr]
	ctrl	ptr[in, cmsghdr]
	ctrllen	len[ctrl, intptr]
	f	flags[send_flags, int32]
# TODO: this field should be deleted
	len	int32
}

recv_msghdr {
	addr	ptr[out, sockaddr]
	addrlen	len[addr, int32]
	vec	ptr[in, array[iovec_out]]
	vlen	len[vec, intptr]
	ctrl	buffer[out]
	ctrllen	len[ctrl, intptr]
	f	int32
# TODO: this field should be deleted
	len	int32
}

cmsghdr {
	len	intptr
	level	int32
	type	int32
# TODO: this is followed by an embed array of aux data, and len is length of the whole message
}

sigset {
	mask	int64
}

sigset_size {
	ss	ptr[inout, sigset]
	len	len[ss, intptr]
}

# prog knowns about this struct type
timespec {
	sec	intptr
	nsec	intptr
}

# prog knowns about this struct type
timeval {
	sec	intptr
	usec	intptr
}

itimerspec {
	interv	timespec
	value	timespec
}

itimerval {
	interv	timeval
	value	timeval
}

utimbuf {
	actime	intptr
	modtime	intptr
}

io_event {
	data	int64
	obj	int64
	res	int64
	res2	int32
}

iocb {
	data	int64
	key	flags[iocb_key, int32]
	pad	int32
	op	flags[lio_opcode, int16]
	prio	int16
	fd	fd
# TODO: in 32-bit mode buf/reserv are still 64 bits
	buf	buffer[inout]
	nbytes	len[buf, int64]
	offset	int64
	reserv	ptr[in, sigevent]
	flags	flags[iocb_flags, int32]
	resfd	fd[event]
}

sigevent {
	val	vma
	signo	signalno
	notify	flags[sigev_notify, int32]
	pad0	int64
	pad1	int64
	pad2	int64
	pad3	int64
	pad4	int64
	pad5	int64
	pad6	int64
	pad7	int64
# TODO: this is actually
# TODO: function pointer needs special support
#  union {
#   int _pad[SIGEV_PAD_SIZE];
#    int _tid;
#   struct {
#    void (*_function)(sigval_t);
#    void *_attribute;/* really pthread_attr_t */
#   } _sigev_thread;
#  } _sigev_un;
}

cap_header {
	var	flags[cap_version, int32]
	pid	pid
}

cap_data {
	eff0	int32
	perm0	int32
	inher0	int32
	eff1	int32
	perm1	int32
	inher1	int32
}

epoll_event {
	ev	flags[epoll_ev, int32]
	pad	int32
	data	int64
}

# fd_set needs to be a separate type
fd_set {
	mask0	int64
	mask1	int64
	mask2	int64
	mask3	int64
	mask4	int64
	mask5	int64
	mask6	int64
	mask7	int64
}

ipc_perm {
	key	int32
	uid	uid
	gid	gid
	cuid	uid
	cgid	gid
	mode	int16
	seq	int16
}

msqid_ds {
	key	int32
	uid	uid
	gid	gid
	cuid	uid
	cgid	gid
	mode	int16
	seq	int16
	stime	intptr
	rtime	intptr
	ctime	intptr
	cbytes	intptr
	qnum	intptr
	qbytes	intptr
	lspid	pid
	lrpid	pid
}

shmid_ds {
	key	int32
	uid	uid
	gid	gid
	cuid	uid
	cgid	gid
	mode	int16
	seq	int16
	segsz	intptr
	atime	intptr
	atime	intptr
	dtime	intptr
	ctime	intptr
	cpid	pid
	lpid	pid
	nattch	intptr
}

semid_ds {
	key	int32
	uid	uid
	gid	gid
	cuid	uid
	cgid	gid
	mode	int16
	seq	int16
	otime	intptr
	ctime	intptr
	nsems	intptr
}

sembuf {
	num	int16
	op	int16
	flg	flags[semop_flags, int64]
}

sock_fprog {
	len	len[filter, intptr]
	filter	ptr[in, array[sock_filter]]
}

sock_filter {
	code	int16
	jt	int8
	kf	int8
	k	int32
}

file_handle {
	bytes	int32
	type	int32
# TODO: again embed array of variable length (bytes is the length)
	handl0	int64
	handl1	int64
	handl2	int64
	handl3	int64
	handl4	int64
	handl5	int64
	handl6	int64
	handl7	int64
	handl8	int64
	handl9	int64
	handl10	int64
	handl11	int64
	handl12	int64
	handl13	int64
	handl14	int64
	handl15	int64
}

mq_attr {
	flags	intptr
	maxmsg	intptr
	msgsize	intptr
	curmsg	intptr
	res0	intptr
	res1	intptr
	res2	intptr
	res3	intptr
}

kexec_segment {
	buf	buffer[in]
	sz	len[buf, intptr]
# TODO: this is address in kernel
	mem	intptr
	memsz	intptr
}

robust_list {
	next	vma
	off	intptr
	pend	vma
}

rusage {
	utime	timeval
	stime	timeval
	maxrss	intptr
	ixrss	intptr
	idrss	intptr
	isrss	intptr
	minflt	intptr
	majflt	intptr
	nswap	intptr
	inblock	intptr
	oublock	intptr
	msgsnd	intptr
	msgrcv	intptr
	signals	intptr
	nvcsw	intptr
	nivcsw	intptr
}

rlimit {
	soft	intptr
	hard	intptr
}

sigaction {
# TODO: function pointers need special support
	handler	intptr
	mask	sigset
	flags	flags[sigaction_flags, intptr]
	restor	intptr
}

tms {
	utime	intptr
	stime	intptr
	cutime	intptr
	cstime	intptr
}

siginfo {
	signo	signalno
	errno	int32
	code	int32
	pad3	int32
# actual size is 128 bytes
}

timex {
	stuff0	intptr
	stuff1	intptr
	stuff2	intptr
	stuff3	intptr
	stuff4	intptr
	stuff5	intptr
	stuff6	intptr
	stuff7	intptr
	stuff8	intptr
	stuff9	intptr
	stuff10	intptr
	stuff11	intptr
	stuff12	intptr
	stuff13	intptr
	stuff14	intptr
	stuff15	intptr
	stuff16	intptr
	stuff17	intptr
	stuff18	intptr
	stuff19	intptr
	stuff20	intptr
	stuff21	intptr
	stuff22	intptr
	stuff23	intptr
	stuff24	intptr
	stuff25	intptr
}

ustat {
	free	int32
	inode	intptr
	nampac0	int32
	nampac1	int32
	nampac2	int32
}

user_desc {
	entry	int32
	base	int32
	limit	int32
	flags	int8
}

sched_attr {
	size	flags[sched_attr_size, int32]
	policy	flags[sched_policy, int32]
	flags	flags[sched_attr_flags2, int64]
	nice	int32
	prio	int32
	runtime	int64
	deadlin	int64
	period	int64
}

flock {
	type	flags[flock_type, int16]
	whence	flags[seek_whence, int16]
	start	intptr
	len	intptr
	pid	pid
}


f_owner_ex {
	type	flags[f_owner_type, int32]
	pid	pid
}

linger {
	onoff	int32
	linger	int32
}

ucred {
	pid	pid
	uid	uid
	gid	gid
}

ip_mreq {
	multi	in_addr
	addr	in_addr
}

ip_mreqn {
	multi	in_addr
	addr	in_addr
	ifindex	int32
}

ip_mreq_source {
	multi	in_addr
	iface	in_addr
	source	in_addr
}

ip_msfilter {
	multi	in_addr
	iface	in_addr
	fmode	flags[ip_msfilter_mode, int32]
	numsrc	flags[ip_msfilter_numsrc, int32]
# TODO: this is variable-length array and numsrc it its length
	slist	in_addr
}

in_pktinfo {
	ifindex	int32
	dst	in_addr
	addr	in_addr
}

# TODO: double-check padding, most likely it is messed up
# (prog does not align fields... maybe it should)
xfrm_filer {
	info	xfrm_userpolicy_info
	tmpl	xfrm_user_tmpl
}

xfrm_userpolicy_info {
	sel	xfrm_selector
	lft	xfrm_lifetime_cfg
	cur	xfrm_lifetime_cur
	prio	int32
	index	int32
	dir	int8
	action	int8
	flags	int8
	share	int8
}

xfrm_user_tmpl {
	id	xfrm_id
	fam	int16
	saddr	in_addr_any
	reqid	int32
	mode	int8
	share	int8
	opt	int8
	aalgod	int32
	ealgos	int32
	calgos	int32
}

xfrm_selector {
	daddr	in_addr_any
	saddr	in_addr_any
	dport	int16
	dmask	int16
	sport	int16
	smask	int16
	fam	int16
	len_d	int8
	len_s	int8
	proto	int8
	ifindex	int32
	user	int32
}

xfrm_lifetime_cfg {
	x0	int64
	x1	int64
	x2	int64
	x3	int64
	x4	int64
	x5	int64
	x6	int64
	x7	int64
}

xfrm_lifetime_cur {
	bytes	int64
	packets	int64
	atime	int64
	utime	int64
}

xfrm_id {
	daddr	in_addr_any
	spi	int32
	proto	int8
}

# in_addr or in6_addr
# prog knows about this struct
in_addr_any {
	a0	in_addr
	a1	int32
	a2	int32
	a3	int32
}

# prog knows about this struct
in6_addr {
	a0	int32
	a1	int32
	a2	int32
	a3	int32
}

ipv6_mreq {
	multi	in6_addr
	ifindex	int32
}

fiemap {
	start	int64
	len	int64
	flags	flags[fiemap_flags, int32]
	mapped	int32
# TODO: count is number of elements in extents array below
	count	int32
	pad	int32
# TODO: this is variable-length array
	extent0	fiemap_extent
	extent1	fiemap_extent
}

fiemap_extent {
	logical	int64
	phys	int64
	len	int64
	pad0	int64
	pad1	int64
	flags	flags[fiemap_extent_flags, int32]
	pad2	int32
	pad3	int32
	pad4	int32
}




open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, O_ASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC
open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
madvise_flags = MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED, MADV_DONTNEED, MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK, MADV_HWPOISON, MADV_SOFT_OFFLINE, MADV_MERGEABLE, MADV_UNMERGEABLE, MADV_HUGEPAGE, MADV_NOHUGEPAGE, MADV_DONTDUMP, MADV_DODUMP
fadvise_flags = POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL, POSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED, POSIX_FADV_DONTNEED
move_pages_flags = MPOL_MF_MOVE, MPOL_MF_MOVE_ALL
msync_flags = MS_ASYNC, MS_SYNC, MS_INVALIDATE
mmap_prot = PROT_EXEC, PROT_READ, PROT_WRITE
mmap_flags = MAP_SHARED, MAP_PRIVATE, MAP_32BIT, MAP_ANONYMOUS, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_FILE, MAP_FIXED, MAP_GROWSDOWN, MAP_HUGETLB, MAP_LOCKED, MAP_NONBLOCK, MAP_NORESERVE, MAP_POPULATE, MAP_STACK, MAP_UNINITIALIZED
mremap_flags = MREMAP_MAYMOVE, MREMAP_FIXED
mbind_mode = MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE, MPOL_PREFERRED, MPOL_F_STATIC_NODES, MPOL_F_RELATIVE_NODES
mbind_flags = MPOL_MF_STRICT, MPOL_MF_MOVE, MPOL_MF_MOVE_ALL
memfd_flags = MFD_CLOEXEC, MFD_ALLOW_SEALING
pipe_flags = O_NONBLOCK, O_CLOEXEC
mlockall_flags = MCL_CURRENT, MCL_FUTURE
dup_flags = O_CLOEXEC
splice_flags = SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT
seek_whence = SEEK_SET, SEEK_CUR, SEEK_END, SEEK_DATA, SEEK_HOLE
socket_domain = AF_LOCAL, AF_INET, AF_INET6, AF_IPX, AF_NETLINK, AF_X25, AF_AX25, AF_ATMPVC, AF_APPLETALK, AF_PACKET
socket_type = SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET, SOCK_RAW, SOCK_RDM, SOCK_PACKET, SOCK_NONBLOCK, SOCK_CLOEXEC
accept_flags = SOCK_NONBLOCK, SOCK_CLOEXEC
shutdown_flags  = SHUT_RD, SHUT_WR
send_flags = MSG_CONFIRM, MSG_DONTROUTE, MSG_DONTWAIT, MSG_EOR, MSG_MORE, MSG_NOSIGNAL, MSG_OOB
recv_flags = MSG_CMSG_CLOEXEC, MSG_DONTWAIT, MSG_ERRQUEUE, MSG_OOB, MSG_PEEK, MSG_TRUNC, MSG_WAITALL, MSG_WAITFORONE
signalfd_flags = SFD_NONBLOCK, SFD_CLOEXEC
eventfd_flags = EFD_CLOEXEC, EFD_NONBLOCK, EFD_SEMAPHORE
timerfd_create_flags = TFD_NONBLOCK, TFD_CLOEXEC
timerfd_settime_flags = TFD_TIMER_ABSTIME
clock_type = CLOCK_REALTIME, CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC, CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_RAW, CLOCK_BOOTTIME, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID
lio_opcode = IOCB_CMD_PREAD, IOCB_CMD_PWRITE, IOCB_CMD_FSYNC, IOCB_CMD_FDSYNC, IOCB_CMD_PREADX, IOCB_CMD_POLL, IOCB_CMD_NOOP, IOCB_CMD_PREADV, IOCB_CMD_PWRITEV
iocb_flags = IOCB_FLAG_RESFD
iocb_key = 0
sigev_notify = SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD
cap_version = 0x19980330, 0x20071026, 0x20080522
prctl_code_void = PR_GET_DUMPABLE, PR_GET_KEEPCAPS, PR_GET_NO_NEW_PRIVS, PR_GET_SECCOMP, PR_GET_SECUREBITS, PR_GET_TIMERSLACK, PR_GET_TIMING, PR_TASK_PERF_EVENTS_DISABLE, PR_TASK_PERF_EVENTS_ENABLE, PR_MCE_KILL_GET
prctl_code_intptr = PR_CAPBSET_READ, PR_CAPBSET_DROP, PR_SET_CHILD_SUBREAPER, PR_SET_DUMPABLE, PR_SET_FPEMU, PR_SET_KEEPCAPS, PR_SET_NO_NEW_PRIVS, PR_SET_PDEATHSIG, PR_SET_SECUREBITS, PR_SET_TIMERSLACK, PR_SET_TIMING, PR_SET_TSC, PR_SET_UNALIGN, PR_MCE_KILL
prctl_code_getreaper = PR_GET_CHILD_SUBREAPER, PR_GET_ENDIAN, PR_GET_FPEMU, PR_GET_FPEXC, PR_GET_PDEATHSIG, PR_GET_TID_ADDRESS, PR_GET_TSC, PR_GET_UNALIGN
prctl_endian = PR_ENDIAN_BIG, PR_ENDIAN_LITTLE, PR_ENDIAN_PPC_LITTLE
prctl_fpexc = PR_FP_EXC_SW_ENABLE, PR_FP_EXC_DIV, PR_FP_EXC_OVF, PR_FP_EXC_UND, PR_FP_EXC_RES, PR_FP_EXC_INV, PR_FP_EXC_DISABLED, PR_FP_EXC_NONRECOV, PR_FP_EXC_ASYNC, PR_FP_EXC_PRECISE
prctl_seccomp_mode = SECCOMP_MODE_DISABLED, SECCOMP_MODE_STRICT, SECCOMP_MODE_FILTER
prctl_mm_option = PR_SET_MM_START_CODE, PR_SET_MM_END_CODE, PR_SET_MM_START_DATA, PR_SET_MM_END_DATA, PR_SET_MM_START_STACK, PR_SET_MM_START_BRK, PR_SET_MM_BRK
arch_prctl_code = ARCH_SET_FS, ARCH_GET_FS, ARCH_SET_GS, ARCH_GET_GS
reqkey_keyring = KEY_REQKEY_DEFL_NO_CHANGE, KEY_REQKEY_DEFL_DEFAULT, KEY_REQKEY_DEFL_THREAD_KEYRING, KEY_REQKEY_DEFL_PROCESS_KEYRING, KEY_REQKEY_DEFL_SESSION_KEYRING, KEY_REQKEY_DEFL_USER_KEYRING, KEY_REQKEY_DEFL_USER_SESSION_KEYRING, KEY_REQKEY_DEFL_GROUP_KEYRING, KEY_REQKEY_DEFL_REQUESTOR_KEYRING
epoll_flags = EPOLL_CLOEXEC
epoll_op = EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL
epoll_ev =  EPOLLIN, EPOLLOUT, EPOLLRDHUP, EPOLLPRI, EPOLLERR, EPOLLHUP, EPOLLET, EPOLLONESHOT
msgget_flags = IPC_CREAT, IPC_EXCL, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
msg_flags = IPC_NOWAIT, MSG_EXCEPT, MSG_NOERROR
msgctl_cmd = IPC_STAT, IPC_SET, IPC_RMID, IPC_INFO, MSG_INFO, MSG_STAT
semget_flags = IPC_CREAT, IPC_EXCL, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
semop_flags = IPC_NOWAIT, SEM_UNDO
semctl_cmd = IPC_STAT, IPC_SET, IPC_RMID, IPC_INFO, SEM_INFO, SEM_STAT, GETALL, GETNCNT, GETPID, GETVAL, GETZCNT, SETALL, SETVAL
shmget_flags = IPC_CREAT, IPC_EXCL, SHM_HUGETLB, SHM_NORESERVE, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
shmat_flags = SHM_RND, SHM_RDONLY, SHM_REMAP
shmctl_cmd = IPC_STAT, IPC_SET, IPC_RMID, IPC_INFO, SHM_INFO, SHM_STAT, SHM_LOCK, SHM_UNLOCK
mknod_mode = S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
fchownat_flags = AT_EMPTY_PATH, AT_SYMLINK_NOFOLLOW
fallocate_mode = 0, FALLOC_FL_KEEP_SIZE, FALLOC_FL_PUNCH_HOLE
linkat_flags = AT_EMPTY_PATH, AT_SYMLINK_FOLLOW
unlinkat_flags = 0, AT_REMOVEDIR
renameat2_flags = RENAME_EXCHANGE, RENAME_NOREPLACE, RENAME_WHITEOUT
flock_op = LOCK_SH, LOCK_EX, LOCK_UN, LOCK_NB
seccomp_op = SECCOMP_SET_MODE_STRICT, SECCOMP_SET_MODE_FILTER
seccomp_flags = 0, SECCOMP_FILTER_FLAG_TSYNC
name_to_handle_at_flags = AT_EMPTY_PATH, AT_SYMLINK_FOLLOW, AT_FDCWD
mq_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_NONBLOCK, O_CREAT, O_EXCL, O_CREAT
mount_flags = MS_BIND, MS_DIRSYNC, MS_MANDLOCK, MS_MOVE, MS_NOATIME, MS_NODEV, MS_NODIRATIME, MS_NOEXEC, MS_NOSUID, MS_RDONLY, MS_RELATIME, MS_REMOUNT, MS_SILENT, MS_STRICTATIME, MS_SYNCHRONOUS
umount_flags = MNT_FORCE, MNT_DETACH, MNT_EXPIRE, UMOUNT_NOFOLLOW
finit_module_flags = MODULE_INIT_IGNORE_MODVERSIONS, MODULE_INIT_IGNORE_VERMAGIC
delete_module_flags = O_NONBLOCK, O_TRUNC
kexec_load_flags = KEXEC_ON_CRASH, KEXEC_PRESERVE_CONTEXT, KEXEC_ARCH_386, KEXEC_ARCH_X86_64, KEXEC_ARCH_PPC, KEXEC_ARCH_PPC64, KEXEC_ARCH_IA_64, KEXEC_ARCH_ARM, KEXEC_ARCH_S390,  KEXEC_ARCH_SH,  KEXEC_ARCH_MIPS, KEXEC_ARCH_MIPS_LE
keyring_type = KEY_SPEC_THREAD_KEYRING, KEY_SPEC_PROCESS_KEYRING, KEY_SPEC_SESSION_KEYRING, KEY_SPEC_USER_KEYRING, KEY_SPEC_USER_SESSION_KEYRING
inotify_flags = IN_NONBLOCK, IN_CLOEXEC
inotify_mask = IN_ACCESS, IN_ATTRIB, IN_CLOSE_WRITE, IN_CLOSE_NOWRITE, IN_CREATE, IN_DELETE, IN_DELETE_SELF, IN_MODIFY, IN_MOVE_SELF, IN_MOVED_FROM, IN_MOVED_TO, IN_OPEN, IN_DONT_FOLLOW, IN_EXCL_UNLINK, IN_MASK_ADD, IN_ONESHOT, IN_ONLYDIR
fanotify_flags = FAN_CLASS_PRE_CONTENT, FAN_CLASS_CONTENT, FAN_CLASS_NOTIF, FAN_CLOEXEC, FAN_NONBLOCK, FAN_UNLIMITED_QUEUE, FAN_UNLIMITED_MARKS
fanotify_events = O_RDONLY, O_WRONLY, O_RDWR, O_LARGEFILE, O_CLOEXEC, O_APPEND, O_DSYNC, O_NOATIME, O_NONBLOCK, O_SYNC
fanotify_mark = FAN_MARK_ADD, FAN_MARK_REMOVE, FAN_MARK_FLUSH, FAN_MARK_DONT_FOLLOW, FAN_MARK_ONLYDIR, FAN_MARK_MOUNT, FAN_MARK_IGNORED_MASK, FAN_MARK_IGNORED_SURV_MODIFY
fanotify_mask = FAN_ACCESS, FAN_MODIFY, FAN_CLOSE_WRITE, FAN_CLOSE_NOWRITE, FAN_OPEN, FAN_OPEN_PERM, FAN_ACCESS_PERM, FAN_ONDIR, FAN_EVENT_ON_CHILD
faccessat_flags = AT_EACCESS, AT_SYMLINK_NOFOLLOW
clone_flags = CLONE_CHILD_CLEARTID, CLONE_CHILD_SETTID, CLONE_FILES, CLONE_FS, CLONE_IO, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, CLONE_NEWPID, CLONE_NEWUTS, CLONE_PARENT, CLONE_PARENT_SETTID, CLONE_PTRACE, CLONE_SETTLS, CLONE_SIGHAND, CLONE_SYSVSEM, CLONE_THREAD, CLONE_UNTRACED, CLONE_VFORK, CLONE_VM
futex_op = FUTEX_WAIT, FUTEX_WAIT_BITSET, FUTEX_WAKE, FUTEX_REQUEUE, FUTEX_CMP_REQUEUE
sync_file_flags = SYNC_FILE_RANGE_WAIT_BEFORE, SYNC_FILE_RANGE_WRITE, SYNC_FILE_RANGE_WAIT_AFTER
kcmp_flags = KCMP_FILE, KCMP_FILES, KCMP_FS, KCMP_IO, KCMP_SIGHAND, KCMP_SYSVSEM, KCMP_VM
rusage_who = RUSAGE_SELF, RUSAGE_CHILDREN, RUSAGE_THREAD
rlimit_type = RLIMIT_AS, RLIMIT_CORE, RLIMIT_CPU, RLIMIT_DATA, RLIMIT_FSIZE, RLIMIT_LOCKS, RLIMIT_MEMLOCK, RLIMIT_MSGQUEUE, RLIMIT_NICE, RLIMIT_NOFILE, RLIMIT_NPROC, RLIMIT_RSS, RLIMIT_RTPRIO, RLIMIT_RTTIME, RLIMIT_SIGPENDING, RLIMIT_STACK
# The ones that disable console output are intentionally omitted.
syslog_cmd = SYSLOG_ACTION_CLOSE, SYSLOG_ACTION_OPEN, SYSLOG_ACTION_READ, SYSLOG_ACTION_READ_ALL, SYSLOG_ACTION_READ_CLEAR, SYSLOG_ACTION_CLEAR, SYSLOG_ACTION_CONSOLE_ON, SYSLOG_ACTION_SIZE_UNREAD, SYSLOG_ACTION_SIZE_BUFFER
ioprio_which_pid = IOPRIO_WHO_PROCESS, IOPRIO_WHO_PGRP
ioprio_which_uid = IOPRIO_WHO_USER
setxattr_flags = XATTR_CREATE, XATTR_REPLACE
ns_type = 0, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWUTS
personality_flags = SYZ_PER_LINUX, SYZ_PER_SVR4, SYZ_PER_SVR3, SYZ_PER_OSR5, SYZ_PER_WYSEV386, SYZ_PER_ISCR4, SYZ_PER_BSD, SYZ_PER_XENIX, SYZ_PER_LINUX32, SYZ_PER_IRIX32, SYZ_PER_IRIXN32, SYZ_PER_IRIX64, SYZ_PER_RISCOS, SYZ_PER_SOLARIS, SYZ_PER_UW7, SYZ_PER_OSF4, SYZ_PER_HPUX, ADDR_NO_RANDOMIZE, MMAP_PAGE_ZERO, ADDR_COMPAT_LAYOUT, READ_IMPLIES_EXEC, ADDR_LIMIT_32BIT, SHORT_INODE, WHOLE_SECONDS, STICKY_TIMEOUTS, ADDR_LIMIT_3GB
sysfs_opt1 = 1
sysfs_opt2 = 2
sysfs_opt3 = 3
clock_id = CLOCK_REALTIME, CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC, CLOCK_MONOTONIC_COARSE, CLOCK_MONOTONIC_RAW, CLOCK_BOOTTIME, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID
sigprocmask_how = SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK
getitimer_which = ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF
wait_options = WNOHANG, WUNTRACED, WCONTINUED, WEXITED, WSTOPPED, WCONTINUED, WNOHANG, WNOWAIT, __WCLONE, __WALL, __WNOTHREAD
waitid_which = P_PID, P_PGID, P_ALL
sigaction_flags = SA_NOCLDSTOP,SA_NOCLDWAIT, SA_NODEFER, SA_ONSTACK, SA_RESETHAND, SA_RESTART, SA_SIGINFO
timer_flags = 0, TIMER_ABSTIME
utimensat_flags = 0, AT_SYMLINK_NOFOLLOW
priority_which = PRIO_PROCESS, PRIO_PGRP, PRIO_USER
sched_policy = SCHED_OTHER, SCHED_BATCH, SCHED_IDLE, SCHED_FIFO, SCHED_RR, SCHED_DEADLINE
sched_attr_flags = 0
sched_attr_flags2 = 0, SCHED_FLAG_RESET_ON_FORK
sched_attr_size = 48
mempolicy_flags = 0, MPOL_F_MEMS_ALLOWED, MPOL_F_ADDR, MPOL_F_NODE
ptrace_req = PTRACE_TRACEME, PTRACE_LISTEN, PTRACE_KILL, PTRACE_INTERRUPT, PTRACE_ATTACH, PTRACE_DETACH
ptrace_req_peek = PTRACE_PEEKTEXT, PTRACE_PEEKDATA
ptrace_req_poke = PTRACE_POKETEXT, PTRACE_POKEDATA
ptrace_req_getregs = PTRACE_GETREGS, PTRACE_GETFPREGS
ptrace_req_setregs = PTRACE_SETREGS, PTRACE_SETFPREGS
ptrace_req_setopts = PTRACE_SETOPTIONS, PTRACE_SEIZE
ptrace_req_cont = PTRACE_CONT, PTRACE_SYSCALL, PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP
pthread_regset = NT_PRSTATUS, NT_PRFPREG, NT_PRPSINFO, NT_TASKSTRUCT, NT_AUXV, NT_386_TLS, NT_386_IOPERM, NT_X86_XSTATE
ptrace_options = PTRACE_O_EXITKILL, PTRACE_O_TRACECLONE, PTRACE_O_TRACEEXEC, PTRACE_O_TRACEEXIT, PTRACE_O_TRACEFORK, PTRACE_O_TRACESYSGOOD, PTRACE_O_TRACEVFORK, PTRACE_O_TRACEVFORKDONE
fcntl_dupfd = F_DUPFD, F_DUPFD_CLOEXEC
fcntl_getflags = F_GETFD, F_GETFL, F_GETSIG, F_GETLEASE, F_GETPIPE_SZ, F_GET_SEALS
fcntl_lock = F_SETLK, F_SETLKW, F_GETLK
fcntl_flags = FD_CLOEXEC
fcntl_status = O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, O_NONBLOCK
flock_type = F_RDLCK, F_WRLCK, F_UNLCK
f_owner_type = F_OWNER_TID, F_OWNER_PID, F_OWNER_PGRP
fcntl_notify = DN_MULTISHOT, DN_ACCESS, DN_MODIFY, DN_CREATE, DN_DELETE, DN_RENAME, DN_ATTRIB
seal_types = F_SEAL_SEAL, F_SEAL_SHRINK, F_SEAL_GROW, F_SEAL_WRITE
sockopt_opt_sock_int = SO_ACCEPTCONN, SO_BROADCAST, SO_DEBUG, SO_DOMAIN, SO_ERROR, SO_DONTROUTE, SO_KEEPALIVE, SO_PEEK_OFF, SO_PRIORITY, SO_PROTOCOL, SO_RCVBUF, SO_RCVBUFFORCE, SO_RCVLOWAT, SO_SNDLOWAT, SO_REUSEADDR, SO_SNDBUF, SO_SNDBUFFORCE, SO_TIMESTAMP, SO_TYPE
sockopt_opt_sock_timeval = SO_RCVTIMEO, SO_SNDTIMEO
sockopt_opt_tcp_int = TCP_CORK, TCP_DEFER_ACCEPT, TCP_KEEPCNT, TCP_KEEPIDLE, TCP_KEEPINTVL, TCP_LINGER2, TCP_MAXSEG, TCP_NODELAY, TCP_QUICKACK, TCP_SYNCNT, TCP_WINDOW_CLAMP
sockopt_opt_ip_int = IP_FREEBIND, IP_HDRINCL, IP_MTU, IP_MULTICAST_ALL, IP_MULTICAST_LOOP, IP_MULTICAST_TTL, IP_NODEFRAG, IP_RECVOPTS, IP_RECVORIGDSTADDR, IP_RECVTOS, IP_RECVTTL, IP_RETOPTS, IP_ROUTER_ALERT, IP_TOS, IP_TRANSPARENT, IP_TTL, IP_RECVERR, IP_PASSSEC, IP_MINTTL, IP_CHECKSUM, IP_BIND_ADDRESS_NO_PORT
sockopt_opt_ip_mreq = IP_ADD_MEMBERSHIP, IP_DROP_MEMBERSHIP, IP_MULTICAST_IF
sockopt_opt_ip_mreqsrc = IP_ADD_SOURCE_MEMBERSHIP, IP_BLOCK_SOURCE, IP_DROP_SOURCE_MEMBERSHIP, IP_UNBLOCK_SOURCE
sockopt_opt_ip_opts = IP_OPTIONS, IP_PKTOPTIONS
ip_msfilter_mode = MCAST_INCLUDE, MCAST_EXCLUDE
ip_msfilter_numsrc = 1
ip_mtu_discover = IP_PMTUDISC_DONT, IP_PMTUDISC_WANT, IP_PMTUDISC_DO, IP_PMTUDISC_PROBE, IP_PMTUDISC_INTERFACE, IP_PMTUDISC_OMIT
sockopt_opt_ipv6_int = IPV6_ADDRFORM, IPV6_MTU, IPV6_MULTICAST_HOPS, IPV6_MULTICAST_IF, IPV6_MULTICAST_LOOP, IPV6_RECVPKTINFO, IPV6_RECVERR, IPV6_ROUTER_ALERT, IPV6_UNICAST_HOPS, IPV6_V6ONLY, IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, IPV6_HOPLIMIT, IPV6_CHECKSUM, IPV6_2292PKTINFO, IPV6_2292HOPOPTS, IPV6_2292DSTOPTS, IPV6_2292RTHDR, IPV6_2292HOPLIMIT
sockopt_opt_ipv6_mreq = IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP, IPV6_JOIN_ANYCAST, IPV6_LEAVE_ANYCAST
ioctl_void = FIOCLEX, FIONCLEX, FIFREEZE, FITHAW
ioctl_int_in = FIONBIO, FIOASYNC
ioctl_int_out = FIOQSIZE, FIGETBSZ
fiemap_flags = FIEMAP_FLAG_SYNC, FIEMAP_FLAG_XATTR, FIEMAP_FLAG_CACHE
fiemap_extent_flags = FIEMAP_EXTENT_LAST, FIEMAP_EXTENT_UNKNOWN, FIEMAP_EXTENT_DELALLOC, FIEMAP_EXTENT_ENCODED, FIEMAP_EXTENT_DATA_ENCRYPTED, FIEMAP_EXTENT_NOT_ALIGNED, FIEMAP_EXTENT_DATA_INLINE, FIEMAP_EXTENT_DATA_TAIL, FIEMAP_EXTENT_UNWRITTEN, FIEMAP_EXTENT_MERGED, FIEMAP_EXTENT_SHARED




# Values that are not available with outdated headers.
define MAP_UNINITIALIZED	0x4000000
define MADV_SOFT_OFFLINE	101
define MPOL_F_STATIC_NODES	(1 << 15)
define MPOL_F_RELATIVE_NODES	(1 << 14)
define PTRACE_SYSEMU		31
define PTRACE_SYSEMU_SINGLESTEP	32
define KCMP_FILE		0
define KCMP_VM			1
define KCMP_FILES		2
define KCMP_FS			3
define KCMP_SIGHAND		4
define KCMP_IO			5
define KCMP_SYSVSEM		6
define KEY_SPEC_THREAD_KEYRING			-1
define KEY_SPEC_PROCESS_KEYRING			-2
define KEY_SPEC_SESSION_KEYRING			-3
define KEY_SPEC_USER_KEYRING			-4
define KEY_SPEC_USER_SESSION_KEYRING		-5
define KEY_SPEC_GROUP_KEYRING			-6
define KEY_SPEC_REQKEY_AUTH_KEY			-7
define KEY_SPEC_REQUESTOR_KEYRING		-8
define KEY_REQKEY_DEFL_NO_CHANGE		-1
define KEY_REQKEY_DEFL_DEFAULT			0
define KEY_REQKEY_DEFL_THREAD_KEYRING		1
define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
define KEY_REQKEY_DEFL_SESSION_KEYRING		3
define KEY_REQKEY_DEFL_USER_KEYRING		4
define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
define KEY_REQKEY_DEFL_GROUP_KEYRING		6
define KEY_REQKEY_DEFL_REQUESTOR_KEYRING	7
define KEYCTL_GET_KEYRING_ID			0
define KEYCTL_JOIN_SESSION_KEYRING		1
define KEYCTL_UPDATE				2
define KEYCTL_REVOKE				3
define KEYCTL_CHOWN				4
define KEYCTL_SETPERM				5
define KEYCTL_DESCRIBE				6
define KEYCTL_CLEAR				7
define KEYCTL_LINK				8
define KEYCTL_UNLINK				9
define KEYCTL_SEARCH				10
define KEYCTL_READ				11
define KEYCTL_INSTANTIATE			12
define KEYCTL_NEGATE				13
define KEYCTL_SET_REQKEY_KEYRING		14
define KEYCTL_SET_TIMEOUT			15
define KEYCTL_ASSUME_AUTHORITY			16
define KEYCTL_GET_SECURITY			17
define KEYCTL_SESSION_TO_PARENT			18
define KEYCTL_REJECT				19
define KEYCTL_INSTANTIATE_IOV			20
define KEYCTL_INVALIDATE			21
define KEYCTL_GET_PERSISTENT			22
define RENAME_NOREPLACE		(1 << 0)
define RENAME_EXCHANGE		(1 << 1)
define RENAME_WHITEOUT		(1 << 2)
define IOCB_CMD_PREADX		4
define IOCB_CMD_POLL		5
define IOPRIO_WHO_PROCESS	1
define IOPRIO_WHO_PGRP		2
define IOPRIO_WHO_USER		3
define MODULE_INIT_IGNORE_MODVERSIONS	1
define MODULE_INIT_IGNORE_VERMAGIC	2
define SYSLOG_ACTION_CLOSE		0
define SYSLOG_ACTION_OPEN		1
define SYSLOG_ACTION_READ		2
define SYSLOG_ACTION_READ_ALL		3
define SYSLOG_ACTION_READ_CLEAR		4
define SYSLOG_ACTION_CLEAR		5
define SYSLOG_ACTION_CONSOLE_OFF	6
define SYSLOG_ACTION_CONSOLE_ON		7
define SYSLOG_ACTION_CONSOLE_LEVEL	8
define SYSLOG_ACTION_SIZE_UNREAD	9
define SYSLOG_ACTION_SIZE_BUFFER	10
define SYZ_PER_LINUX		0x0000
define SYZ_PER_SVR4		0x0001
define SYZ_PER_SVR3		0x0002
define SYZ_PER_OSR5		0x0003
define SYZ_PER_WYSEV386		0x0004
define SYZ_PER_ISCR4		0x0005
define SYZ_PER_BSD		0x0006
define SYZ_PER_XENIX		0x0007
define SYZ_PER_LINUX32		0x0008
define SYZ_PER_IRIX32		0x0009
define SYZ_PER_IRIXN32		0x000a
define SYZ_PER_IRIX64		0x000b
define SYZ_PER_RISCOS		0x000c
define SYZ_PER_SOLARIS 		0x000d
define SYZ_PER_UW7		0x000e
define SYZ_PER_OSF4		0x000f
define SYZ_PER_HPUX		0x0010
define SCHED_DEADLINE		6
define SCHED_FLAG_RESET_ON_FORK	1
define IP_PMTUDISC_INTERFACE	4
define IP_PMTUDISC_OMIT		5
define IP_NODEFRAG		22
define IP_CHECKSUM		23
define IP_BIND_ADDRESS_NO_PORT	24
define IPV6_FLOWINFO		11
define MFD_CLOEXEC		0x0001U
define MFD_ALLOW_SEALING	0x0002U
define F_ADD_SEALS		(1024 + 9)
define F_GET_SEALS		(1024 + 10)
define F_SEAL_SEAL		0x0001
define F_SEAL_SHRINK		0x0002
define F_SEAL_GROW		0x0004
define F_SEAL_WRITE		0x0008




# Not yet implemented syscalls
#define __NR_clone 56
#define __NR_fork 57
#define __NR_vfork 58
#define __NR_execve 59
#define __NR_getcwd 79
#define __NR_chdir 80
#define __NR_fchdir 81
#define __NR_umask 95
#define __NR_vhangup 153
#define __NR_modify_ldt 154
#define __NR__sysctl 156
#define __NR_adjtimex 159
#define __NR_chroot 161
#define __NR_swapon 167
#define __NR_swapoff 168
#define __NR_quotactl 179
#define __NR_nfsservctl 180
#define __NR_perf_event_open 298
#define __NR_getcpu 309
#define __NR_process_vm_readv 310
#define __NR_process_vm_writev 311




# Probably no sense in calling there.
# Also affect system-wide state, so not reproducble anyway.
#define __NR_gettimeofday 96
#define __NR_settimeofday 164
#define __NR_reboot 169
#define __NR_sethostname 170
#define __NR_setdomainname 171
#define __NR_sched_get_priority_max 146
#define __NR_sched_get_priority_min 147




# KDBUS support

# TODO: something must create kdbus fds
# syz_kdbus_open(...) fd[kdbus]

ioctl$kdbus_bus_make(fd fd[kdbus], cmd const[KDBUS_CMD_BUS_MAKE], arg ptr[in, kdbus_cmd_bus_make])
ioctl$kdbus_ep_make(fd fd[kdbus], cmd const[KDBUS_CMD_ENDPOINT_MAKE], arg ptr[in, kdbus_cmd_ep_make])
ioctl$kdbus_ep_update(fd fd[kdbus], cmd const[KDBUS_CMD_ENDPOINT_UPDATE], arg ptr[in, kdbus_cmd_ep_update])
ioctl$kdbus_hello(fd fd[kdbus], cmd const[KDBUS_CMD_HELLO], arg ptr[in, kdbus_cmd_hello])
ioctl$kdbus_name_acquire(fd fd[kdbus], cmd const[KDBUS_CMD_NAME_ACQUIRE], arg ptr[in, kdbus_cmd_name_acquire])
ioctl$kdbus_name_release(fd fd[kdbus], cmd const[KDBUS_CMD_NAME_RELEASE], arg ptr[in, kdbus_cmd_name_release])
ioctl$kdbus_free(fd fd[kdbus], cmd const[KDBUS_CMD_FREE], arg ptr[in, kdbus_cmd_free])
ioctl$kdbus_recv(fd fd[kdbus], cmd const[KDBUS_CMD_RECV], arg ptr[in, kdbus_cmd_recv])
ioctl$kdbus_send(fd fd[kdbus], cmd const[KDBUS_CMD_SEND], arg ptr[in, kdbus_cmd_send])
ioctl$kdbus_update(fd fd[kdbus], cmd const[KDBUS_CMD_UPDATE], arg ptr[in, kdbus_cmd_update])
ioctl$kdbus_bye(fd fd[kdbus], cmd const[KDBUS_CMD_BYEBYE], arg ptr[in, kdbus_cmd_bye])
ioctl$kdbus_conn_info(fd fd[kdbus], cmd const[KDBUS_CMD_CONN_INFO], arg ptr[in, kdbus_cmd_info])
ioctl$kdbus_bus_info(fd fd[kdbus], cmd const[KDBUS_CMD_BUS_CREATOR_INFO], arg ptr[in, kdbus_cmd_info])
ioctl$kdbus_list(fd fd[kdbus], cmd const[KDBUS_CMD_LIST], arg ptr[in, kdbus_cmd_list])
ioctl$kdbus_match_add(fd fd[kdbus], cmd const[KDBUS_CMD_MATCH_ADD], arg ptr[in, kdbus_cmd_match])
ioctl$kdbus_match_remove(fd fd[kdbus], cmd const[KDBUS_CMD_MATCH_REMOVE], arg ptr[in, kdbus_cmd_match])

kdbus_cmd_bus_make {
	size	len[parent, int64]
	flags	flags[kdbus_make_flags, int64]
	rflags	const[0, int64]
	bloom	kdbus_bloom_parameter
	name	kdbus_make_name_parameter
}

kdbus_cmd_ep_make {
	size	len[parent, int64]
	flags	flags[kdbus_make_flags, int64]
	rflags	const[0, int64]
	name	kdbus_make_name_parameter
}

kdbus_cmd_ep_update {
	size	len[parent, int64]
	flags	flags[kdbus_make_flags, int64]
	rflags	const[0, int64]

	name	kdbus_make_name_parameter
	policy	kdbus_policy_parameter
}

kdbus_cmd_hello {
	size	len[parent, int64]
	flags	flags[kdbus_hello_flags, int64]
	rflags	const[0, int64]

	sflags	flags[kdbus_attach_flags, int64]
	rflags	flags[kdbus_attach_flags, int64]
	bflags	int64
	id	int64
	poolsz	int64
	off	int64
	isize	int64
	id0	int64
	id1	int64

	name	kdbus_make_name_parameter
	policy	kdbus_policy_parameter
	pids	kdbus_pids_parameter
	creds	kdbus_creds_parameter
	seclab	kdbus_seclabel_parameter
}

kdbus_cmd_bye {
	size	len[parent, int64]
	flags	const[0, int64]
	rflags	const[0, int64]
}

kdbus_cmd_list {
	size	len[parent, int64]
	flags	flags[kdbus_list_flags, int64]
	rflags	const[0, int64]
	off	int64
	lsize	const[0, int64]
}

kdbus_cmd_update {
	size	len[parent, int64]
	flags	flags[kdbus_name_flags, int64]
	rflags	const[0, int64]

	name	kdbus_make_name_parameter
	policy	kdbus_policy_parameter
	attach	kdbus_attach_flags_parameter
}

kdbus_cmd_name_acquire {
	size	len[parent, int64]
	flags	flags[kdbus_name_flags, int64]
	rflags	const[0, int64]
	name	kdbus_make_name_parameter
}

kdbus_cmd_name_release {
	size	len[parent, int64]
	flags	const[0, int64]
	rflags	const[0, int64]
	name	kdbus_make_name_parameter
}

kdbus_cmd_match {
	size	len[parent, int64]
	flags	flags[kdbus_match_flags, int64]
	rflags	const[0, int64]
# TODO: this needs to match between add and remove
	cookie	int64

	bloom	kdbus_bloom_parameter
	name0	kdbus_name_parameter
	name1	kdbus_name_parameter
	name2	kdbus_name_parameter
	name3	kdbus_name_parameter
	idadd	kdbus_id_change_parameter
	idremov	kdbus_id_change_parameter
	id	kdbus_id_parameter
	dstid	kdbus_id_parameter
}

kdbus_cmd_free {
	size	len[parent, int64]
	flags	int64
	rflags	const[0, int64]
	off	int64
# TODO: followed by arbitrary sequence of parameters
}

kdbus_cmd_recv {
	size	len[parent, int64]
	flags	flags[kdbus_recv_flags, int64]
	rflags	const[0, int64]
	prio	int64
	dropped	int64
	msg	kdbus_msg_info
# TODO: followed by arbitrary sequence of parameters
}

kdbus_cmd_send {
	size	len[parent, int64]
	flags	flags[kdbus_send_flags, int64]
	rflags	const[0, int64]
	msg	ptr[in, kdbus_msg]
	reply	kdbus_msg_info
	fd	kdbus_fd_parameter
}

kdbus_msg {
	size	len[parent, int64]
	flags	flags[kdbus_msg_flags, int64]
	rflags	const[0, int64]

	vec0	kdbus_payload_vec
	vec1	kdbus_payload_vec
	memfd0	kdbus_payload_memfd
	memfd1	kdbus_payload_memfd
	fds	kdbus_fd_parameter
	bloom	kdbus_bloom_parameter
	dname	kdbus_dst_name_parameter
}

kdbus_msg_info {
	off	int64
	size	int64
	rflags	const[0, int64]
}

kdbus_cmd_info {
	size	len[parent, int64]
	flags	const[0, int64]
	rflags	const[0, int64]

# TODO: this is connection id, need to extract it from somewhere
	id	int64
	aflags	flags[kdbus_attach_flags, int64]
# TODO: off is offset in the caller's pool buffer where the kdbus_info struct result is stored.
# It needs to be passed to KDBUS_CMD_FREE, so it should be a resource.
	off	int64
	isize	const[0, int64]
# TODO: name is optional if id is specified
	name	kdbus_make_name_parameter
}

kdbus_bloom_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_BLOOM_PARAMETER, int64]
	bsize	int64
	hash	int64
}

kdbus_make_name_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_MAKE_NAME, int64]
# TODO: this is embed strz buffer of variable-length
	name	int64
}

kdbus_dst_name_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_DST_NAME, int64]
# TODO: this is embed strz buffer of variable-length
	name	int64
}

kdbus_name_parameter {
	size	len[parent, int64]
	type	flags[kdbus_name_params, int64]
	flags	flags[kdbus_name_flags, int64]
# TODO: this is embed var-len string
	name	int64
}

kdbus_negotiate_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_NEGOTIATE, int64]
}

kdbus_policy_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_POLICY_ACCESS, int64]
	ptype	flags[kdbus_policy_access, int64]
	access	flags[kdbus_policy_flags, int64]
	id	uid
}

kdbus_attach_flags_parameter {
	size	len[parent, int64]
	type	flags[kdbug_attach_type, int64]
	flags	flags[kdbus_attach_flags, int64]
}

kdbus_fd_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_CANCEL_FD, int64]
# TODO: this can be embed var-len array
	fd	fd
}

kdbus_pids_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_PIDS, int64]
	pid	pid
	pad0	int32
	tid	pid
	pad1	int32
	ppid	pid
	pad2	int32
}

kdbus_creds_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_CREDS, int64]
	uid	uid
	pad0	int32
	euid	uid
	pad1	int32
	suid	uid
	pad2	int32
	fsuid	uid
	pad3	int32
	gid	uid
	pad4	int32
	egid	uid
	pad5	int32
	sgid	uid
	pad6	int32
	fsgid	uid
	pad7	int32
}

kdbus_seclabel_parameter {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_SECLABEL, int64]
# TODO: this is some var-len string of unknown nature
	label	int64	
}

kdbus_payload_vec {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_PAYLOAD_VEC, int64]
	size	len[data, int64]
	data	buffer[in]
}

kdbus_payload_memfd {
	size	len[parent, int64]
	type	const[KDBUS_ITEM_PAYLOAD_MEMFD, int64]
	start	int64
	size	int64
	fd	fd
	pad	int32
}

kdbus_id_change_parameter {
	size	len[parent, int64]
	type	flags[kdbus_id_change_type, int64]
	id	const[0, int64]
	flags	const[0, int64]
}

kdbus_id_parameter {
	size	len[parent, int64]
	type	flags[kdbus_id_type, int64]
# TODO: what is this id?
	id	int64
}

kdbus_make_flags = KDBUS_MAKE_ACCESS_GROUP, KDBUS_MAKE_ACCESS_WORLD
kdbus_hello_flags = KDBUS_HELLO_ACCEPT_FD, KDBUS_HELLO_ACTIVATOR, KDBUS_HELLO_POLICY_HOLDER, KDBUS_HELLO_MONITOR
kdbus_attach_flags = KDBUS_ATTACH_TIMESTAMP, KDBUS_ATTACH_CREDS, KDBUS_ATTACH_PIDS, KDBUS_ATTACH_AUXGROUPS, KDBUS_ATTACH_NAMES, KDBUS_ATTACH_TID_COMM, KDBUS_ATTACH_PID_COMM, KDBUS_ATTACH_EXE, KDBUS_ATTACH_CMDLINE, KDBUS_ATTACH_CGROUP, KDBUS_ATTACH_CAPS, KDBUS_ATTACH_SECLABEL, KDBUS_ATTACH_AUDIT, KDBUS_ATTACH_CONN_DESCRIPTION, KDBUS_ATTACH_ANY
kdbus_name_flags = KDBUS_NAME_REPLACE_EXISTING, KDBUS_NAME_ALLOW_REPLACEMENT, KDBUS_NAME_QUEUE, KDBUS_NAME_IN_QUEUE, KDBUS_NAME_ACTIVATOR, KDBUS_NAME_PRIMARY, KDBUS_NAME_ACQUIRED
kdbus_recv_flags = KDBUS_RECV_RETURN_INCOMPLETE_FDS, KDBUS_RECV_RETURN_DROPPED_MSGS
kdbus_send_flags = KDBUS_SEND_SYNC_REPLY
kdbus_policy_access = KDBUS_POLICY_ACCESS_NULL, KDBUS_POLICY_ACCESS_USER, KDBUS_POLICY_ACCESS_GROUP, KDBUS_POLICY_ACCESS_WORLD
kdbus_policy_flags = KDBUS_POLICY_OWN, KDBUS_POLICY_TALK, KDBUS_POLICY_SEE
kdbug_attach_type = KDBUS_ITEM_ATTACH_FLAGS_SEND, KDBUS_ITEM_ATTACH_FLAGS_RECV
kdbus_msg_flags = KDBUS_MSG_EXPECT_REPLY, KDBUS_MSG_NO_AUTO_START, KDBUS_MSG_SIGNAL
kdbus_list_flags = KDBUS_LIST_UNIQUE, KDBUS_LIST_NAMES, KDBUS_LIST_ACTIVATORS, KDBUS_LIST_QUEUED
kdbus_match_flags = KDBUS_MATCH_REPLACE
kdbus_name_params = KDBUS_ITEM_NAME, KDBUS_ITEM_NAME_ADD, KDBUS_ITEM_NAME_REMOVE, KDBUS_ITEM_NAME_CHANGE
kdbus_id_change_type = KDBUS_ITEM_ID_ADD, KDBUS_ITEM_ID_REMOVE
kdbus_id_type = KDBUS_ITEM_ID, KDBUS_ITEM_DST_ID

define KDBUS_IOCTL_MAGIC		0x95
define KDBUS_CMD_BUS_MAKE		_IOW(KDBUS_IOCTL_MAGIC, 0x00, int)
define KDBUS_CMD_ENDPOINT_MAKE		_IOW(KDBUS_IOCTL_MAGIC, 0x10, int)
define KDBUS_CMD_ENDPOINT_UPDATE	_IOW(KDBUS_IOCTL_MAGIC, 0x11, int)
define KDBUS_CMD_HELLO			_IOWR(KDBUS_IOCTL_MAGIC, 0x80, int)
define KDBUS_CMD_UPDATE			_IOW(KDBUS_IOCTL_MAGIC, 0x81, int)
define KDBUS_CMD_BYEBYE			_IOW(KDBUS_IOCTL_MAGIC, 0x82, int)
define KDBUS_CMD_FREE			_IOW(KDBUS_IOCTL_MAGIC, 0x83, int)
define KDBUS_CMD_CONN_INFO		_IOR(KDBUS_IOCTL_MAGIC, 0x84, int)
define KDBUS_CMD_BUS_CREATOR_INFO	_IOR(KDBUS_IOCTL_MAGIC, 0x85, int)
define KDBUS_CMD_LIST			_IOR(KDBUS_IOCTL_MAGIC, 0x86, int)
define KDBUS_CMD_SEND			_IOW(KDBUS_IOCTL_MAGIC, 0x90, int)
define KDBUS_CMD_RECV			_IOR(KDBUS_IOCTL_MAGIC, 0x91, int)
define KDBUS_CMD_NAME_ACQUIRE		_IOW(KDBUS_IOCTL_MAGIC, 0xa0, int)
define KDBUS_CMD_NAME_RELEASE		_IOW(KDBUS_IOCTL_MAGIC, 0xa1, int)
define KDBUS_CMD_MATCH_ADD		_IOW(KDBUS_IOCTL_MAGIC, 0xb0, int)
define KDBUS_CMD_MATCH_REMOVE		_IOW(KDBUS_IOCTL_MAGIC, 0xb1, int)

define KDBUS_MAKE_ACCESS_GROUP		(1ULL <<  0)
define KDBUS_MAKE_ACCESS_WORLD		(1ULL <<  1)

define KDBUS_HELLO_ACCEPT_FD		(1ULL <<  0)
define KDBUS_HELLO_ACTIVATOR		(1ULL <<  1)
define KDBUS_HELLO_POLICY_HOLDER	(1ULL <<  2)
define KDBUS_HELLO_MONITOR		(1ULL <<  3)

define KDBUS_ATTACH_TIMESTAMP		1ULL <<  0
define KDBUS_ATTACH_CREDS		1ULL <<  1
define KDBUS_ATTACH_PIDS		1ULL <<  2
define KDBUS_ATTACH_AUXGROUPS		1ULL <<  3
define KDBUS_ATTACH_NAMES		1ULL <<  4
define KDBUS_ATTACH_TID_COMM		1ULL <<  5
define KDBUS_ATTACH_PID_COMM		1ULL <<  6
define KDBUS_ATTACH_EXE			1ULL <<  7
define KDBUS_ATTACH_CMDLINE		1ULL <<  8
define KDBUS_ATTACH_CGROUP		1ULL <<  9
define KDBUS_ATTACH_CAPS		1ULL << 10
define KDBUS_ATTACH_SECLABEL		1ULL << 11
define KDBUS_ATTACH_AUDIT		1ULL << 12
define KDBUS_ATTACH_CONN_DESCRIPTION	1ULL << 13
define KDBUS_ATTACH_ANY			~0ULL

define KDBUS_NAME_REPLACE_EXISTING	1ULL <<  0
define KDBUS_NAME_ALLOW_REPLACEMENT	1ULL <<  1
define KDBUS_NAME_QUEUE			1ULL <<  2
define KDBUS_NAME_IN_QUEUE		1ULL <<  3
define KDBUS_NAME_ACTIVATOR		1ULL <<  4
define KDBUS_NAME_PRIMARY		1ULL <<  5
define KDBUS_NAME_ACQUIRED		1ULL <<  6

define KDBUS_RECV_RETURN_INCOMPLETE_FDS	1ULL <<  0
define KDBUS_RECV_RETURN_DROPPED_MSGS	1ULL <<  1

define KDBUS_SEND_SYNC_REPLY		1ULL << 0

define KDBUS_LIST_UNIQUE		1ULL <<  0
define KDBUS_LIST_NAMES			1ULL <<  1
define KDBUS_LIST_ACTIVATORS		1ULL <<  2
define KDBUS_LIST_QUEUED		1ULL <<  3

define KDBUS_POLICY_ACCESS_NULL		0
define KDBUS_POLICY_ACCESS_USER		1
define KDBUS_POLICY_ACCESS_GROUP	2
define KDBUS_POLICY_ACCESS_WORLD	3

define KDBUS_POLICY_SEE			0
define KDBUS_POLICY_TALK		1
define KDBUS_POLICY_OWN			2

define KDBUS_MATCH_REPLACE		1ULL <<  0

define KDBUS_MSG_EXPECT_REPLY		1ULL << 0
define KDBUS_MSG_NO_AUTO_START		1ULL << 1
define KDBUS_MSG_SIGNAL			1ULL << 2

define KDBUS_ITEM_NEGOTIATE		1
define KDBUS_ITEM_PAYLOAD_VEC		2
define KDBUS_ITEM_PAYLOAD_OFF		3
define KDBUS_ITEM_PAYLOAD_MEMFD		4
define KDBUS_ITEM_FDS			5
define KDBUS_ITEM_CANCEL_FD		6
define KDBUS_ITEM_BLOOM_PARAMETER	7
define KDBUS_ITEM_BLOOM_FILTER		8
define KDBUS_ITEM_BLOOM_MASK		9
define KDBUS_ITEM_DST_NAME		10
define KDBUS_ITEM_MAKE_NAME		11
define KDBUS_ITEM_ATTACH_FLAGS_SEND	12
define KDBUS_ITEM_ATTACH_FLAGS_RECV	13
define KDBUS_ITEM_ID			14
define KDBUS_ITEM_NAME			15
define KDBUS_ITEM_DST_ID		16
define KDBUS_ITEM_TIMESTAMP		(0x1000 + 0)
define KDBUS_ITEM_CREDS			(0x1000 + 1)
define KDBUS_ITEM_PIDS			(0x1000 + 2)
define KDBUS_ITEM_AUXGROUPS		(0x1000 + 3)
define KDBUS_ITEM_OWNED_NAME		(0x1000 + 4)
define KDBUS_ITEM_TID_COMM		(0x1000 + 5)
define KDBUS_ITEM_PID_COM		(0x1000 + 6)
define KDBUS_ITEM_EXE			(0x1000 + 7)
define KDBUS_ITEM_CMDLINE		(0x1000 + 8)
define KDBUS_ITEM_CGROUP		(0x1000 + 9)
define KDBUS_ITEM_CAPS			(0x1000 + 10)
define KDBUS_ITEM_SECLABEL		(0x1000 + 11)
define KDBUS_ITEM_AUDIT			(0x1000 + 12)
define KDBUS_ITEM_CONN_DESCRIPTION	(0x1000 + 13)
define KDBUS_ITEM_POLICY_ACCESS		(0x2000 + 0)
define KDBUS_ITEM_NAME_ADD		(0x8000 + 0)
define KDBUS_ITEM_NAME_REMOVE		(0x8000 + 1)
define KDBUS_ITEM_NAME_CHANGE		(0x8000 + 2)
define KDBUS_ITEM_ID_ADD		(0x8000 + 3)
define KDBUS_ITEM_ID_REMOVE		(0x8000 + 4)
define KDBUS_ITEM_REPLY_TIMEOUT		(0x8000 + 5)
define KDBUS_ITEM_REPLY_DEAD		(0x8000 + 6)




# tty support

open$ptmx(file strconst["/dev/ptmx"], flags flags[open_flags], mode const[0]) fd[tty]
syz_openpts(fd fd[tty], flags flags[open_flags]) fd[tty]
ioctl$TCGETS(fd fd[tty], cmd const[TCGETS], arg ptr[out, termios])
ioctl$TCSETS(fd fd[tty], cmd const[TCSETS], arg ptr[in, termios])
ioctl$TCSETSW(fd fd[tty], cmd const[TCSETS], arg ptr[in, termios])
ioctl$TCSETSF(fd fd[tty], cmd const[TCSETSF], arg ptr[in, termios])
ioctl$TCGETA(fd fd[tty], cmd const[TCGETA], arg ptr[out, termio])
ioctl$TCSETA(fd fd[tty], cmd const[TCSETS], arg ptr[in, termio])
ioctl$TCSETAW(fd fd[tty], cmd const[TCSETS], arg ptr[in, termio])
ioctl$TCSETAF(fd fd[tty], cmd const[TCSETSF], arg ptr[in, termio])
ioctl$TIOCGLCKTRMIOS(fd fd[tty], cmd const[TIOCGLCKTRMIOS], arg ptr[in, termios])
ioctl$TIOCSLCKTRMIOS(fd fd[tty], cmd const[TIOCSLCKTRMIOS], arg ptr[out, termios])
ioctl$TIOCGWINSZ(fd fd[tty], cmd const[TIOCGWINSZ], arg ptr[out, winsize])
ioctl$TIOCSWINSZ(fd fd[tty], cmd const[TIOCSWINSZ], arg ptr[in, winsize])
ioctl$TCSBRK(fd fd[tty], cmd const[TCSBRK], arg intptr)
ioctl$TCSBRKP(fd fd[tty], cmd const[TCSBRKP], arg intptr)
ioctl$TIOCSBRK(fd fd[tty], cmd const[TIOCSBRK])
ioctl$TIOCCBRK(fd fd[tty], cmd const[TIOCCBRK])
ioctl$TCXONC(fd fd[tty], cmd const[TCXONC], arg intptr)
ioctl$FIONREAD(fd fd[tty], cmd const[FIONREAD], arg ptr[out, int32])
ioctl$TIOCOUTQ(fd fd[tty], cmd const[TIOCOUTQ], arg ptr[out, int32])
ioctl$TCFLSH(fd fd[tty], cmd const[TCFLSH], arg intptr)
ioctl$TIOCSTI(fd fd[tty], cmd const[TIOCSTI], arg intptr)
ioctl$TIOCCONS(fd fd[tty], cmd const[TIOCCONS])
ioctl$TIOCSCTTY(fd fd[tty], cmd const[TIOCSCTTY], arg intptr)
ioctl$TIOCNOTTY(fd fd[tty], cmd const[TIOCNOTTY])
ioctl$TIOCGPGRP(fd fd[tty], cmd const[TIOCGPGRP], arg ptr[out, pid])
ioctl$TIOCSPGRP(fd fd[tty], cmd const[TIOCGPGRP], arg ptr[in, pid])
ioctl$TIOCGSID(fd fd[tty], cmd const[TIOCGPGRP], arg ptr[out, pid])
ioctl$TIOCEXCL(fd fd[tty], cmd const[TIOCEXCL])
ioctl$TIOCNXCL(fd fd[tty], cmd const[TIOCNXCL])
ioctl$TIOCGETD(fd fd[tty], cmd const[TIOCGETD], arg ptr[out, int32])
ioctl$TIOCSETD(fd fd[tty], cmd const[TIOCSETD], arg ptr[in, int32])
ioctl$TIOCPKT(fd fd[tty], cmd const[TIOCPKT], arg ptr[in, int32])
ioctl$TIOCMGET(fd fd[tty], cmd const[TIOCMGET], arg ptr[out, int32])
ioctl$TIOCMSET(fd fd[tty], cmd const[TIOCMSET], arg ptr[in, int32])
ioctl$TIOCMBIC(fd fd[tty], cmd const[TIOCMBIC], arg ptr[in, int32])
ioctl$TIOCMBIS(fd fd[tty], cmd const[TIOCMBIC], arg ptr[in, int32])
ioctl$TIOCGSOFTCAR(fd fd[tty], cmd const[TIOCGSOFTCAR], arg ptr[out, int32])
ioctl$TIOCSSOFTCAR(fd fd[tty], cmd const[TIOCSSOFTCAR], arg ptr[in, int32])
ioctl$TIOCTTYGSTRUCT(fd fd[tty], cmd const[TIOCSSOFTCAR], arg buffer[out])

# For the TIOCLINUX ioctl, see console_ioctl(4).

ioctl$KDGETLED(fd fd[tty], cmd const[KDGETLED], arg ptr[out, int8])
ioctl$KDSETLED(fd fd[tty], cmd const[KDSETLED], arg intptr)
ioctl$KDGKBLED(fd fd[tty], cmd const[KDGKBLED], arg ptr[out, int8])
ioctl$KDSKBLED(fd fd[tty], cmd const[KDSKBLED], arg intptr)
ioctl$KDGKBTYPE(fd fd[tty], cmd const[KDGKBTYPE], arg ptr[out, int8])
ioctl$KDADDIO(fd fd[tty], cmd const[KDADDIO], arg intptr)
ioctl$KDDELIO(fd fd[tty], cmd const[KDDELIO], arg intptr)
ioctl$KDENABIO(fd fd[tty], cmd const[KDENABIO])
ioctl$KDDISABIO(fd fd[tty], cmd const[KDDISABIO])
ioctl$KDSETMODE(fd fd[tty], cmd const[KDSETMODE], arg intptr)
ioctl$KDGETMODE(fd fd[tty], cmd const[KDGETMODE], arg ptr[out, intptr])
ioctl$KDMKTONE(fd fd[tty], cmd const[KDGETMODE], arg intptr)
ioctl$KIOCSOUND(fd fd[tty], cmd const[KIOCSOUND], arg intptr)
ioctl$GIO_CMAP(fd fd[tty], cmd const[GIO_CMAP], arg ptr[out, io_cmap])
ioctl$PIO_CMAP(fd fd[tty], cmd const[GIO_CMAP], arg ptr[in, io_cmap])
ioctl$GIO_FONT(fd fd[tty], cmd const[GIO_FONT], arg buffer[out])
ioctl$GIO_FONTX(fd fd[tty], cmd const[GIO_FONTX], arg buffer[out])
ioctl$PIO_FONT(fd fd[tty], cmd const[PIO_FONT], arg buffer[in])
ioctl$PIO_FONTX(fd fd[tty], cmd const[PIO_FONTX], arg buffer[in])
ioctl$PIO_FONTRESET(fd fd[tty], cmd const[PIO_FONTRESET], arg const[0])
ioctl$GIO_SCRNMAP(fd fd[tty], cmd const[GIO_SCRNMAP], arg buffer[out])
ioctl$GIO_UNISCRNMAP(fd fd[tty], cmd const[GIO_UNISCRNMAP], arg buffer[out])
ioctl$PIO_SCRNMAP(fd fd[tty], cmd const[PIO_SCRNMAP], arg buffer[in])
ioctl$PIO_UNISCRNMAP(fd fd[tty], cmd const[PIO_UNISCRNMAP], arg buffer[in])
ioctl$GIO_UNIMAP(fd fd[tty], cmd const[GIO_UNIMAP], arg ptr[in, unimapdesc_out])
ioctl$PIO_UNIMAP(fd fd[tty], cmd const[PIO_UNIMAP], arg ptr[in, unimapdesc_in])
ioctl$PIO_UNIMAPCLR(fd fd[tty], cmd const[PIO_UNIMAPCLR], arg ptr[in, unimapinit])
ioctl$KDGKBMODE(fd fd[tty], cmd const[KDGKBMODE], arg ptr[out, intptr])
ioctl$KDSKBMODE(fd fd[tty], cmd const[KDSKBMODE], arg ptr[in, intptr])
ioctl$KDGKBMETA(fd fd[tty], cmd const[KDGKBMETA], arg ptr[out, intptr])
ioctl$KDSKBMETA(fd fd[tty], cmd const[KDSKBMETA], arg ptr[in, intptr])
ioctl$KDGKBENT(fd fd[tty], cmd const[KDGKBENT], arg ptr[in, kbentry])
ioctl$KDGKBSENT(fd fd[tty], cmd const[KDGKBSENT], arg ptr[in, kbentry])
ioctl$KDSKBSENT(fd fd[tty], cmd const[KDSKBSENT], arg buffer[in])
ioctl$KDGKBDIACR(fd fd[tty], cmd const[KDGKBDIACR], arg buffer[out])
ioctl$KDGETKEYCODE(fd fd[tty], cmd const[KDGETKEYCODE], arg ptr[in, kbkeycode])
ioctl$KDSETKEYCODE(fd fd[tty], cmd const[KDSETKEYCODE], arg ptr[in, kbkeycode])
ioctl$KDSIGACCEPT(fd fd[tty], cmd const[KDSIGACCEPT], arg signalno)
ioctl$VT_OPENQRY(fd fd[tty], cmd const[VT_OPENQRY], arg ptr[out, int32])
ioctl$VT_GETMODE(fd fd[tty], cmd const[VT_GETMODE], arg ptr[out, vt_mode])
ioctl$VT_SETMODE(fd fd[tty], cmd const[VT_SETMODE], arg ptr[in, vt_mode])
ioctl$VT_GETSTATE(fd fd[tty], cmd const[VT_GETSTATE], arg ptr[in, vt_stat])
ioctl$VT_RELDISP(fd fd[tty], cmd const[VT_RELDISP])
ioctl$VT_ACTIVATE(fd fd[tty], cmd const[VT_ACTIVATE], arg intptr)
ioctl$VT_WAITACTIVE(fd fd[tty], cmd const[VT_WAITACTIVE])
ioctl$VT_DISALLOCATE(fd fd[tty], cmd const[VT_DISALLOCATE])
ioctl$VT_RESIZE(fd fd[tty], cmd const[VT_RESIZE], arg ptr[in, vt_sizes])
ioctl$VT_RESIZEX(fd fd[tty], cmd const[VT_RESIZEX], arg ptr[in, vt_consize])
ioctl$TIOCLINUX2(fd fd[tty], cmd const[TIOCLINUX], arg ptr[in, tiocl_selection])
ioctl$TIOCLINUX3(fd fd[tty], cmd const[TIOCLINUX], arg ptr[in, const[3, int8]])
ioctl$TIOCLINUX4(fd fd[tty], cmd const[TIOCLINUX], arg ptr[in, const[4, int8]])
ioctl$TIOCLINUX5(fd fd[tty], cmd const[TIOCLINUX], arg ptr[in, loadlut])
ioctl$TIOCLINUX6(fd fd[tty], cmd const[TIOCLINUX], arg ptr[in, tiocl_shift_state])
ioctl$TIOCLINUX7(fd fd[tty], cmd const[TIOCLINUX], arg ptr[in, tiocl_report_mouse])

termios {
	iflag	int32
	oflag	int32
	cflag	int32
	lflag	int32
	line	int8
	cc0	int8
	cc1	int8
	cc2	int8
	cc3_6	int32
	cc7_10	int32
	cc11_14	int32
	cc15_18	int32
}

termio {
	iflag	int16
	oflag	int16
	cflag	int16
	lflag	int16
	line	int8
	cc0	int8
	cc1	int8
	cc2	int8
	cc3_6	int32
	cc7	int8
}

winsize {
	row	int16
	col	int16
	xpix	int16
	upix	int16
}

io_cmap {
	map0	int64
	map1	int64
	map2	int64
	map3	int64
	map4	int64
	map5	int64
}

unimapdesc_in {
	cnt	len[entries, int16]
	entries	ptr[in, array[unipair]]
}

unimapdesc_out {
	cnt	len[entries, int16]
	entries	ptr[out, array[unipair]]
}

unipair {
	unicode	int16
	fontpos	int16
}

unimapinit {
	size	int16
	step	int16
	level	int16
}

kbentry {
	table	int8
	index	int8
	value	int16
}

kbkeycode {
	scan	int32
	key	int32
}

vt_mode {
	mode	int8
	waitv	int8
	relsig	int16
	acqsig	int16
	frsig	int16
}

vt_stat {
	active	int16
	signal	int16
	state	int16
}

vt_sizes {
	rows	int16
	cols	int16
	scroll	int16
}

vt_consize {
	rows	int16
	cols	int16
	vlin	int16
	clin	int16
	vcol	int16
	ccol	int16
}

tiocl_selection {
	subcode	const[2, int8]
	xs	int16
	ys	int16
	xe	int16
	ye	int16
	mode	int16
}

loadlut {
	submode	const[5, int8]
	pad	int8
	pad	int8
	pad	int8
	tab0	int64
	tab1	int64
	tab2	int64
	tab3	int64
}

tiocl_shift_state {
	subcode	const[6, int8]
	shift	int8
}

tiocl_report_mouse {
	subcode	const[7, int8]
	shift	int8
}




# DRI/DRM support

syz_dri_open(card_id intptr, flags flags[open_flags]) fd[dri]
ioctl$DRM_IOCTL_VERSION(fd fd[dri], cmd const[DRM_IOCTL_VERSION], arg ptr[in, drm_version])
ioctl$DRM_IOCTL_GET_UNIQUE(fd fd[dri], cmd const[DRM_IOCTL_GET_UNIQUE], arg ptr[in, drm_unique])
ioctl$DRM_IOCTL_GET_MAGIC(fd fd[dri], cmd const[DRM_IOCTL_GET_MAGIC], arg ptr[in, int32])
ioctl$DRM_IOCTL_IRQ_BUSID(fd fd[dri], cmd const[DRM_IOCTL_IRQ_BUSID], arg ptr[in, drm_irq_busid])
ioctl$DRM_IOCTL_GET_MAP(fd fd[dri], cmd const[DRM_IOCTL_GET_MAP], arg ptr[in, drm_map])
ioctl$DRM_IOCTL_GET_CLIENT(fd fd[dri], cmd const[DRM_IOCTL_GET_CLIENT], arg ptr[in, drm_client])
ioctl$DRM_IOCTL_GET_STATS(fd fd[dri], cmd const[DRM_IOCTL_GET_STATS], arg buffer[out])
ioctl$DRM_IOCTL_GET_CAP(fd fd[dri], cmd const[DRM_IOCTL_GET_CAP], arg ptr[in, drm_get_cap])
ioctl$DRM_IOCTL_SET_CLIENT_CAP(fd fd[dri], cmd const[DRM_IOCTL_SET_CLIENT_CAP], arg ptr[in, drm_get_cap])
ioctl$DRM_IOCTL_SET_VERSION(fd fd[dri], cmd const[DRM_IOCTL_SET_VERSION], arg ptr[in, drm_set_version])

drm_version {
	maj	int32
	min	int32
	patch	int32
	namelen	len[name, intptr]
	name	buffer[out]
	datelen	len[date, intptr]
	date	buffer[out]
	desclen	len[desc, intptr]
	desc	buffer[out]
}

drm_unique {
	len	len[uni, intptr]
	uni	buffer[out]
}

drm_irq_busid {
	irq	int32
	bus	int32
	dev	int32
	func	int32
}

drm_map {
	off	intptr
	size	intptr
	type	flags[drm_map_type, int32]
	flags	flags[drm_map_flags, int32]
	handle	vma
	mtrr	int32
}

drm_client {
	idx	int32
	auth	int32
	pid	pid
# pid is declared is long
	pid_pad	int32
	uid	uid
# uid is declared is long
	uid_pad	int32
	magic	intptr
	iocs	intptr
}

drm_get_cap {
	cap	int64
	val	int64
}

drm_set_version {
	di_maj	int32
	di_min	int32
	dd_maj	int32
	dd_min	int32
}

drm_map_type = _DRM_FRAME_BUFFER, _DRM_REGISTERS, _DRM_SHM, _DRM_AGP, _DRM_SCATTER_GATHER, _DRM_CONSISTENT
drm_map_flags = _DRM_RESTRICTED, _DRM_READ_ONLY, _DRM_LOCKED, _DRM_KERNEL, _DRM_WRITE_COMBINING, _DRM_CONTAINS_LOCK, _DRM_REMOVABLE, _DRM_DRIVER




# FUSE support

syz_fuse_mount(target filename, mode flags[fuse_mode], uid uid, gid gid, maxread intptr, flags flags[mount_flags]) fd[fuse]
syz_fuseblk_mount(target filename, blkdev filename, mode flags[fuse_mode], uid uid, gid gid, maxread intptr, blksize intptr, flags flags[mount_flags]) fd[fuse]
ioctl$FUSE_DEV_IOC_CLONE(fd fd[fuse], cmd const[FUSE_DEV_IOC_CLONE], arg ptr[in, fd[fuse]])
write$fuse_init(fd fd[fuse], arg ptr[in, fuse_init_out], len len[arg])
write$fuse_interrupt(fd fd[fuse], arg ptr[in, fuse_interrupt_out], len len[arg])
write$fuse_bmap(fd fd[fuse], arg ptr[in, fuse_bmap_out], len len[arg])
write$fuse_ioctl(fd fd[fuse], arg ptr[in, fuse_ioctl_out], len len[arg])
write$fuse_poll(fd fd[fuse], arg ptr[in, fuse_poll_out], len len[arg])
write$fuse_notify_poll_wakeup(fd fd[fuse], arg ptr[in, fuse_notify_poll_wakeup_out], len len[arg])
write$fuse_notify_inval_inode(fd fd[fuse], arg ptr[in, fuse_notify_inval_inode_out], len len[arg])
write$fuse_notify_inval_entry(fd fd[fuse], arg ptr[in, fuse_notify_inval_entry_out], len len[arg])
write$fuse_notify_delete(fd fd[fuse], arg ptr[in, fuse_notify_delete_out], len len[arg])
write$fuse_notify_store(fd fd[fuse], arg ptr[in, fuse_notify_store_out], len len[arg])
write$fuse_notify_retrieve(fd fd[fuse], arg ptr[in, fuse_notify_retrieve_out], len len[arg])

# 1 stands for default_permissions, 2 - allow_other
fuse_mode = 1, 2, S_IFREG, S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK, S_IFLNK, S_IFDIR

define FUSE_DEV_IOC_CLONE	_IOR(229, 0, uint32_t)

fuse_init_out {
	len	len[parent, int32]
	err	int32
	unique	int64

	maj	int32
	min	int32
	readah	int32
	flags	int32
	backg	int16
	congest	int16
	maxwr	int32
	timegr	int32
	unused0	const[0, int32]
	unused1	const[0, int32]
	unused2	const[0, int32]
	unused3	const[0, int32]
	unused4	const[0, int32]
	unused5	const[0, int32]
	unused6	const[0, int32]
	unused7	const[0, int32]
	unused8	const[0, int32]
}

fuse_interrupt_out {
	len	len[parent, int32]
	err	int32
	unique	int64
}

fuse_bmap_out {
	len	len[parent, int32]
	err	int32
	unique	int64

	block	int64
}

fuse_ioctl_out {
	len	len[parent, int32]
	err	int32
	unique	int64

	res	int32
	flags	int32
	iniovs	int32
	outiovs	int32
}

fuse_poll_out {
	len	len[parent, int32]
	err	int32
	unique	int64

	revents	int32
	pad	int32
}

fuse_notify_poll_wakeup_out {
	len	len[parent, int32]
	err	int32
	unique	const[0, int64]

	kh	int16
}

fuse_notify_inval_inode_out {
	len	len[parent, int32]
	err	int32
	unique	const[0, int64]

	ino	int64
	off	int64
	len	int16
}

fuse_notify_inval_entry_out {
	len	len[parent, int32]
	err	int32
	unique	const[0, int64]

	parent	int64
	namelen	int32
	pad	const[0, int32]
}

fuse_notify_delete_out {
	len	len[parent, int32]
	err	int32
	unique	const[0, int64]

	parent	int64
	child	int64
	namelen	int32
	pad	const[0, int32]
}

fuse_notify_store_out {
	len	len[parent, int32]
	err	int32
	unique	const[0, int64]

	nodeid	int64
	off	int64
	size	int32
	pad	const[0, int32]
}

fuse_notify_retrieve_out {
	len	len[parent, int32]
	err	int32
	unique	const[0, int64]

	unique	int64
	nodeid	int64
	off	int64
	size	int32
	pad	const[0, int32]
}
